<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Times+New+Roman:300,300italic,400,400italic,700,700italic%7CGeorgia:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hwchai.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Numpy是Python中科学计算的核心库。它提供了一个多维数组对象，以及用于高并发处理这些数组的向量化计算工具集。NumPy允许用户在Python环境中进行向量和矩阵计算，并且由于许多底层函数实际上是用C编写的，因此你可以体验在原生Python中永远无法体验到的速度。NumPy绝对是Python在科学计算领域成功的关键之一，如果你想要进入Python中的数据科学或机器学习，你就要必须学习它。H">
<meta property="og:type" content="article">
<meta property="og:title" content="Python在科研中的应用 03：科学计算环境 NumPy">
<meta property="og:url" content="https://hwchai.com/PythonLes04/index.html">
<meta property="og:site_name" content="Hai-Wei Chai&#39;s Blog">
<meta property="og:description" content="Numpy是Python中科学计算的核心库。它提供了一个多维数组对象，以及用于高并发处理这些数组的向量化计算工具集。NumPy允许用户在Python环境中进行向量和矩阵计算，并且由于许多底层函数实际上是用C编写的，因此你可以体验在原生Python中永远无法体验到的速度。NumPy绝对是Python在科学计算领域成功的关键之一，如果你想要进入Python中的数据科学或机器学习，你就要必须学习它。H">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s21.ax1x.com/2024/10/17/pAUMSfI.png">
<meta property="og:image" content="https://pic1.zhimg.com/v2-90de7812f9fc3169cffb7e39d4c3cfd8_r.jpg">
<meta property="og:image" content="https://pic4.zhimg.com/v2-6e73db4bcf9e406d110da4f2827200ab_r.jpg">
<meta property="og:image" content="https://s21.ax1x.com/2024/03/25/pF5SVln.png">
<meta property="og:image" content="https://s21.ax1x.com/2024/03/25/pF5SZyq.png">
<meta property="article:published_time" content="2024-03-20T11:03:58.000Z">
<meta property="article:modified_time" content="2024-03-20T16:32:01.000Z">
<meta property="article:author" content="Hai-Wei Chai (柴海伟)">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="NumPy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s21.ax1x.com/2024/10/17/pAUMSfI.png">


<link rel="canonical" href="https://hwchai.com/PythonLes04/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://hwchai.com/PythonLes04/","path":"PythonLes04/","title":"Python在科研中的应用 03：科学计算环境 NumPy"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Python在科研中的应用 03：科学计算环境 NumPy | Hai-Wei Chai's Blog</title>
  







<link rel="dns-prefetch" href="https://vercel.hwchai.com/">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hai-Wei Chai's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-house-chimney fa-fw"></i>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-list fa-fw"></i>Archives</a></li><li class="menu-item menu-item-support"><a href="/support/" rel="section"><i class="fa fa-screwdriver-wrench fa-fw"></i>Support</a></li><li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>Books</a></li><li class="menu-item menu-item-scholar"><a href="/scholar/" rel="section"><i class="fa fa-chart-column fa-fw"></i>Scholar</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E6%95%B0%E7%BB%84"><span class="nav-number">1.</span> <span class="nav-text">创建数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%88%9B%E5%BB%BA"><span class="nav-number">1.1.</span> <span class="nav-text">直接创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA"><span class="nav-number">1.2.</span> <span class="nav-text">内置函数创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="nav-number">1.3.</span> <span class="nav-text">创建多维数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E5%B1%9E%E6%80%A7"><span class="nav-number">1.4.</span> <span class="nav-text">数组属性</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E6%A0%87%E9%87%8F"><span class="nav-number">2.1.</span> <span class="nav-text">数组标量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%BA%A2%E5%87%BA%E9%94%99%E8%AF%AF"><span class="nav-number">2.2.</span> <span class="nav-text">溢出错误</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E7%B2%BE%E5%BA%A6"><span class="nav-number">2.3.</span> <span class="nav-text">扩展精度</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95"><span class="nav-number">3.</span> <span class="nav-text">数组索引</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8D%95%E5%85%83%E7%B4%A0%E7%B4%A2%E5%BC%95"><span class="nav-number">3.1.</span> <span class="nav-text">单元素索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%87%E7%89%87%E7%B4%A2%E5%BC%95%EF%BC%88Slicing%EF%BC%89"><span class="nav-number">3.2.</span> <span class="nav-text">切片索引（Slicing）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95"><span class="nav-number">3.3.</span> <span class="nav-text">整数数组索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B8%83%E5%B0%94%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95"><span class="nav-number">3.4.</span> <span class="nav-text">布尔数组索引</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%BF%E6%92%AD-Broadcasting"><span class="nav-number">4.</span> <span class="nav-text">广播(Broadcasting)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E5%AD%A6"><span class="nav-number">5.</span> <span class="nav-text">数组中的基本数学</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%82%B9%E7%A7%AF%E8%BF%90%E7%AE%97%E5%8E%9F%E7%90%86"><span class="nav-number">5.1.</span> <span class="nav-text">点积运算原理</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E4%BA%A4%E6%8D%A2"><span class="nav-number">6.</span> <span class="nav-text">字节交换</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E8%8A%82%E6%8E%92%E5%BA%8F%E5%92%8Cndarrays%E7%AE%80%E4%BB%8B"><span class="nav-number">6.1.</span> <span class="nav-text">字节排序和ndarrays简介</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9B%B4%E6%94%B9%E5%AD%97%E8%8A%82%E9%A1%BA%E5%BA%8F"><span class="nav-number">6.2.</span> <span class="nav-text">更改字节顺序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E7%BB%84"><span class="nav-number">7.</span> <span class="nav-text">结构化数组</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8B%E7%BB%8D"><span class="nav-number">7.1.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%9B%E5%BB%BA"><span class="nav-number">7.2.</span> <span class="nav-text">结构化数据类型创建</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E5%92%8C%E6%98%BE%E7%A4%BA%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.3.</span> <span class="nav-text">操作和显示结构化数据类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E5%8A%A8%E5%AD%97%E8%8A%82%E5%81%8F%E7%A7%BB%E5%92%8C%E5%AF%B9%E9%BD%90"><span class="nav-number">7.4.</span> <span class="nav-text">自动字节偏移和对齐</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E6%AE%B5%E6%A0%87%E9%A2%98"><span class="nav-number">7.5.</span> <span class="nav-text">字段标题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%81%94%E5%90%88%E7%B1%BB%E5%9E%8B"><span class="nav-number">7.6.</span> <span class="nav-text">联合类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E6%95%B0%E6%8D%AE%E5%88%86%E9%85%8D%E7%BB%99%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E7%BB%84"><span class="nav-number">7.7.</span> <span class="nav-text">将数据分配给结构化数组</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E7%BB%84"><span class="nav-number">7.8.</span> <span class="nav-text">索引结构化数组</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hai-Wei Chai (柴海伟)"
      src="/images/gamersky.gif">
  <p class="site-author-name" itemprop="name">Hai-Wei Chai (柴海伟)</p>
  <div class="site-description" itemprop="description">I am a slow walker, but never backwards!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">32</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">33</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/haiweichai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;haiweichai" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chw9402@mail.ustc.edu.com" title="E-Mail → mailto:chw9402@mail.ustc.edu.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hwchai.com/PythonLes04/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gamersky.gif">
      <meta itemprop="name" content="Hai-Wei Chai (柴海伟)">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hai-Wei Chai's Blog">
      <meta itemprop="description" content="I am a slow walker, but never backwards!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Python在科研中的应用 03：科学计算环境 NumPy | Hai-Wei Chai's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Python在科研中的应用 03：科学计算环境 NumPy
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-03-20 11:03:58" itemprop="dateCreated datePublished" datetime="2024-03-20T11:03:58Z">2024-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-03-20 16:32:01" itemprop="dateModified" datetime="2024-03-20T16:32:01Z">2024-03-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming-language/" itemprop="url" rel="index"><span itemprop="name">Programming language</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline: </span>
  
    <a title="waline" href="/PythonLes04/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/PythonLes04/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><img src="https://s21.ax1x.com/2024/10/17/pAUMSfI.png"></p>
<p>Numpy是Python中科学计算的核心库。它提供了一个多维数组对象，以及用于高并发处理这些数组的向量化计算工具集。NumPy允许用户在Python环境中进行向量和矩阵计算，并且由于许多底层函数实际上是用C编写的，因此你可以体验在原生Python中永远无法体验到的速度。NumPy绝对是Python在科学计算领域成功的关键之一，如果你想要进入Python中的数据科学或机器学习，你就要必须学习它。Have a good day!</p>
<span id="more"></span>

<h2 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h2><p>NumPy数组是一个值网格，所有类型都相同，并由非负整数元组索引。创建数组通常有5种常规机制：</p>
<ul>
<li>从其他Python结构（例如，列表，元组，array_like）转换</li>
<li>numpy原生数组的创建（例如，arange、ones、zeros等）</li>
<li>从磁盘读取数组，无论是标准格式还是自定义格式</li>
<li>通过使用字符串或缓冲区从原始字节创建数组</li>
<li>使用特殊库函数（例如，random）</li>
</ul>
<h3 id="直接创建"><a href="#直接创建" class="headerlink" title="直接创建"></a>直接创建</h3><p>通常，在Python中排列成array-like结构的数值数据可以通过使用array()函数转换为数组。最明显的例子是列表和元组。np.array() 直接创建：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure>

<img src="https://pic1.zhimg.com/v2-90de7812f9fc3169cffb7e39d4c3cfd8_r.jpg" width="45%" alt="np.array()创建数组" align=center />

<p>对于一维数组，我们在写数组的时候是横着写的，而其实数组是列向量。</p>
<h3 id="内置函数创建"><a href="#内置函数创建" class="headerlink" title="内置函数创建"></a>内置函数创建</h3><p>Numpy内置了从头开始创建数组的函数，<code>zeros()</code>将创建一个用指定形状用0填充的数组。默认的<code>dtype</code>是<code>float64</code>。使用 np.ones()、np.zeros()、np.random.random() 等方法：</p>
<img src="https://pic4.zhimg.com/v2-6e73db4bcf9e406d110da4f2827200ab_r.jpg" width="100%" alt="np.ones(), np.zeros(), np.random.random()创建数组" align=center />

<p>NumPy同样可以创建多维数组。数组的形状（shape）是一个整数元组，给出了每个维度的数组大小。我们可以从嵌套的Python列表初始化NumPy数组，并使用方括号访问元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])   <span class="comment"># Create a rank 1 array</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a))            <span class="comment"># Prints &quot;&lt;class &#x27;numpy.ndarray&#x27;&gt;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a.shape)            <span class="comment"># Prints &quot;(3,)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>], a[<span class="number">1</span>], a[<span class="number">2</span>])   <span class="comment"># Prints &quot;1 2 3&quot;</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">5</span>                  <span class="comment"># Change an element of the array</span></span><br><span class="line"><span class="built_in">print</span>(a)                  <span class="comment"># Prints &quot;[5, 2, 3]&quot;</span></span><br><span class="line"></span><br><span class="line">b = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])    <span class="comment"># Create a rank 2 array</span></span><br><span class="line"><span class="built_in">print</span>(b.shape)                     <span class="comment"># Prints &quot;(2, 3)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(b[<span class="number">0</span>, <span class="number">0</span>], b[<span class="number">0</span>, <span class="number">1</span>], b[<span class="number">1</span>, <span class="number">0</span>])   <span class="comment"># Prints &quot;1 2 4&quot;</span></span><br></pre></td></tr></table></figure>

<p>我们再来看一些例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">b = np.array((<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">c = np.arange(<span class="number">5</span>)</span><br><span class="line">d = np.linspace(<span class="number">0</span>, <span class="number">2</span>*np.pi, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)     <span class="comment"># &gt;&gt;&gt;[0 1 2 3 4]</span></span><br><span class="line"><span class="built_in">print</span>(b)     <span class="comment"># &gt;&gt;&gt;[0 1 2 3 4]</span></span><br><span class="line"><span class="built_in">print</span>(c)     <span class="comment"># &gt;&gt;&gt;[0 1 2 3 4]</span></span><br><span class="line"><span class="built_in">print</span>(d)     <span class="comment"># &gt;&gt;&gt;[ 0.  1.57079633  3.14159265  4.71238898  6.28318531]</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">3</span>])  <span class="comment"># &gt;&gt;&gt;3</span></span><br></pre></td></tr></table></figure>

<p>上面的代码显示了创建数组的4种不同方法。最基本的方法是将序列传递给NumPy的<code>array()</code>函数; 你可以传递任何序列（类数组），而不仅仅是常见的列表（list）数据类型。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;np.arange(<span class="number">3</span>)</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">&gt;&gt;&gt;np.arange(<span class="number">3.0</span>)</span><br><span class="line">array([ <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>])</span><br><span class="line">&gt;&gt;&gt;np.arange(<span class="number">3</span>,<span class="number">7</span>)</span><br><span class="line">array([<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">&gt;&gt;&gt;np.arange(<span class="number">3</span>,<span class="number">7</span>,<span class="number">2</span>)</span><br><span class="line">array([<span class="number">3</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>

<p><code>np.arange()</code>函数对于整数参数，该函数大致相当于Python内置的<code>range()</code>。当使用非整数步长（例如0.1）时，通常使用<a target="_blank" rel="noopener" href="https://github.com/numpy/numpy/blob/v1.26.0/numpy/core/function_base.py#L24-L182">numpy.linspace</a>更好。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">numpy.linspace(start, stop, num=<span class="number">50</span>, endpoint=<span class="literal">True</span>, retstep=<span class="literal">False</span>, dtype=<span class="literal">None</span>, axis=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>start: array_like 序列的起始值；</li>
<li>stop: array_like 序列的结束值，除非endpoint被设置为False。在这种情况下，序列由除num+1个均匀间隔样本的最后一个之外的所有样本组成，因此stop值被排除在外。注意，当endpoint为False时，步长会发生变化。</li>
<li>num: int 可选项，要生成的样本数量，默认值是50，必须为非负整数；</li>
<li>endpoint: bool 可选项，如果为True，则最后一个元素为stop值，否则不包含。默认为True；</li>
<li>retstep: bool 可选项，如果True，返回(samples, step)，其中step是采样之间的间隔。</li>
<li>dtype: dtype 可选项，输出数组的数据类型。如果不指定dtype，则从start和stop推断数据类型。推断的dtype永远不会是整型；即使参数将产生一个整数数组，也选择float。</li>
<li>axis: int 可选项，1.9.0新版功能。Axis在结果中存储样品。只有当start或stop是数组类型时才相关。默认情况下(0)，样本将沿着在开始时插入的新轴。用-1得到最后的轴。</li>
</ul>
<p>这个创建函数的优点是可以保证元素的数量以及开始和结束点，对于任意的开始，停止和步骤值，<code>arange()</code>通常不会这样做。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;np.linspace(<span class="number">2.0</span>, <span class="number">3.0</span>, num=<span class="number">5</span>)</span><br><span class="line">array([<span class="number">2.</span>  , <span class="number">2.25</span>, <span class="number">2.5</span> , <span class="number">2.75</span>, <span class="number">3.</span>  ])</span><br><span class="line">&gt;&gt;&gt;np.linspace(<span class="number">2.0</span>, <span class="number">3.0</span>, num=<span class="number">5</span>, endpoint=<span class="literal">False</span>)</span><br><span class="line">array([<span class="number">2.</span> ,  <span class="number">2.2</span>,  <span class="number">2.4</span>,  <span class="number">2.6</span>,  <span class="number">2.8</span>])</span><br><span class="line">&gt;&gt;&gt;np.linspace(<span class="number">2.0</span>, <span class="number">3.0</span>, num=<span class="number">5</span>, retstep=<span class="literal">True</span>)</span><br><span class="line">(array([<span class="number">2.</span>  ,  <span class="number">2.25</span>,  <span class="number">2.5</span> ,  <span class="number">2.75</span>,  <span class="number">3.</span>  ]), <span class="number">0.25</span>)</span><br></pre></td></tr></table></figure>

<p>同样类似的函数还有<code>geomspace()</code>以及<code>logspace()</code>，功能与<code>linspace()</code>函数类似，分别对应生成指数级数与对数级数数组，在此不做过多介绍。</p>
<h3 id="创建多维数组"><a href="#创建多维数组" class="headerlink" title="创建多维数组"></a>创建多维数组</h3><p>上面的数组示例是如何使用NumPy表示向量的，接下来我们将看看如何使用多维数组表示矩阵和更多的信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span> ,<span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">2</span>,<span class="number">4</span>]) <span class="comment"># &gt;&gt;&gt;25</span></span><br></pre></td></tr></table></figure>

<p>为了创建一个二维数组，我们传递一个列表的列表（或者是一个序列的序列）给<code>array()</code>函数。如果我们想要一个3D（三维）数组，我们就要传递一个列表的列表的列表，如果是一个4D（四维）数组，那就是列表的列表的列表的列表，以此类推。请注意2D（二维）数组是如何按行和列排列的。要索引2D（二维）数组，我们只需引用行数和列数即可。</p>
<p>我们再来看看一些二维情况下创建数组的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.zeros((<span class="number">2</span>,<span class="number">2</span>))   <span class="comment"># Create an array of all zeros</span></span><br><span class="line"><span class="built_in">print</span>(a)              <span class="comment"># Prints &quot;[[ 0.  0.]</span></span><br><span class="line">                      <span class="comment">#          [ 0.  0.]]&quot;</span></span><br><span class="line"></span><br><span class="line">b = np.ones((<span class="number">1</span>,<span class="number">2</span>))    <span class="comment"># Create an array of all ones</span></span><br><span class="line"><span class="built_in">print</span>(b)              <span class="comment"># Prints &quot;[[ 1.  1.]]&quot;</span></span><br><span class="line"></span><br><span class="line">c = np.full((<span class="number">2</span>,<span class="number">2</span>), <span class="number">7</span>)  <span class="comment"># Create a constant array</span></span><br><span class="line"><span class="built_in">print</span>(c)               <span class="comment"># Prints &quot;[[ 7.  7.]</span></span><br><span class="line">                       <span class="comment">#          [ 7.  7.]]&quot;</span></span><br><span class="line"></span><br><span class="line">d = np.eye(<span class="number">2</span>)         <span class="comment"># Create a 2x2 identity matrix</span></span><br><span class="line"><span class="built_in">print</span>(d)              <span class="comment"># Prints &quot;[[ 1.  0.]</span></span><br><span class="line">                      <span class="comment">#          [ 0.  1.]]&quot;</span></span><br><span class="line"></span><br><span class="line">e = np.random.random((<span class="number">2</span>,<span class="number">2</span>))  <span class="comment"># Create an array filled with random values</span></span><br><span class="line"><span class="built_in">print</span>(e)                     <span class="comment"># Might print &quot;[[ 0.91940167  0.08143941]</span></span><br><span class="line">                             <span class="comment">#               [ 0.68744134  0.87236687]]&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="数组属性"><a href="#数组属性" class="headerlink" title="数组属性"></a>数组属性</h3><p>在使用NumPy时，你会想知道数组的某些信息。很幸运，NumPy包里边包含了很多便捷的方法，可以给你想要的信息。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Array properties</span></span><br><span class="line">a = np.array([[<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">              [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>, <span class="number">20</span>],</span><br><span class="line">              [<span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>, <span class="number">24</span>, <span class="number">25</span>],</span><br><span class="line">              [<span class="number">26</span>, <span class="number">27</span>, <span class="number">28</span> ,<span class="number">29</span>, <span class="number">30</span>],</span><br><span class="line">              [<span class="number">31</span>, <span class="number">32</span>, <span class="number">33</span>, <span class="number">34</span>, <span class="number">35</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(a)) <span class="comment"># &gt;&gt;&gt;&lt;class &#x27;numpy.ndarray&#x27;&gt;</span></span><br><span class="line"><span class="built_in">print</span>(a.dtype) <span class="comment"># &gt;&gt;&gt;int64</span></span><br><span class="line"><span class="built_in">print</span>(a.size) <span class="comment"># &gt;&gt;&gt;25</span></span><br><span class="line"><span class="built_in">print</span>(a.shape) <span class="comment"># &gt;&gt;&gt;(5, 5)</span></span><br><span class="line"><span class="built_in">print</span>(a.itemsize) <span class="comment"># &gt;&gt;&gt;8</span></span><br><span class="line"><span class="built_in">print</span>(a.ndim) <span class="comment"># &gt;&gt;&gt;2</span></span><br><span class="line"><span class="built_in">print</span>(a.nbytes) <span class="comment"># &gt;&gt;&gt;200</span></span><br></pre></td></tr></table></figure>

<p>正如你在上面的代码中看到的，NumPy数组实际上被称为<code>&#39;numpy.ndarray&#39;</code>。</p>
<ul>
<li><p><code>shape</code>属性是数组有多少行和列，上面的数组有5行和5列，所以它的shape是(5, 5)。</p>
</li>
<li><p><code>itemsize</code>属性是每个项占用的字节（Byte）数。这个数组的数据类型是<code>int64</code>，一个<code>int64</code>中有64 bit，1 byte &#x3D; 8 bit，即为8 byte。</p>
</li>
<li><p><code>ndim</code>属性是数组的维数，在本例中为2。</p>
</li>
<li><p><code>nbytes</code>属性是数组中的所有数据消耗掉的字节数。这并不计算数组信息定义开销，因此数组占用的实际内存空间将稍微大一点。</p>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>每个NumPy数组都是相同类型元素的网格。NumPy提供了一组可用于构造数组的大量数值数据类型。NumPy在创建数组时尝试猜测数据类型，但构造数组的函数通常还包含一个可选参数来显式指定数据类型。这是一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>])   <span class="comment"># Let numpy choose the datatype</span></span><br><span class="line"><span class="built_in">print</span>(x.dtype)         <span class="comment"># Prints &quot;int64&quot;</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1.0</span>, <span class="number">2.0</span>])   <span class="comment"># Let numpy choose the datatype</span></span><br><span class="line"><span class="built_in">print</span>(x.dtype)             <span class="comment"># Prints &quot;float64&quot;</span></span><br><span class="line"></span><br><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>], dtype=np.int64)   <span class="comment"># Force a particular datatype</span></span><br><span class="line"><span class="built_in">print</span>(x.dtype)                         <span class="comment"># Prints &quot;int64&quot;</span></span><br></pre></td></tr></table></figure>

<p>NumPy支持比Python更多种类的数字类型。本节显示了哪些可用，以及如何修改数组的数据类型。支持的原始类型与 C 中的原始类型紧密相关：</p>
<img src="https://s21.ax1x.com/2024/03/25/pF5SVln.png" width="85%" alt="NumPy数据类型1" align=center />

<p>由于其中许多都具有依赖于平台的定义，因此提供了一组固定大小的别名：</p>
<img src="https://s21.ax1x.com/2024/03/25/pF5SZyq.png" width="85%" alt="NumPy数据类型2" align=center />

<p>NumPy数值类型是<code>dtype</code>（数据类型）对象的实例，每个对象都具有独特的特征。导入NumPy后使用，在<code>dtypes</code>可作为<code>np.bool_</code>，<code>np.float32</code>等等。</p>
<p>上表中未列出的高级类型将在后续的课程中教授结构化数组时进行探讨。</p>
<p>有5种基本数字类型表示布尔值（bool），整数（int），无符号整数（uint）浮点（float）和复数（complex）。名称中带有数字的那些表示该类型的位大小（即，在内存中表示单个值需要多少位）。某些类型（例如<code>int</code>和<code>intp</code>）具有不同的位，取决于平台（例如，32位与64位计算机）。在与寻址原始内存的低层代码（例如C或Fortran）连接时，应考虑这一点。</p>
<p>数据类型可以用作将Python数转换为数组标量的函数，将Python数字序列转换为该类型的数组，或作为许多NumPy函数或方法接受的<code>dtype</code>关键字的参数。一些例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.float32(<span class="number">1.0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line"><span class="number">1.0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = np.int_([<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y</span><br><span class="line">array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z = np.arange(<span class="number">3</span>, dtype=np.uint8)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>z</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], dtype=uint8)</span><br></pre></td></tr></table></figure>

<p>数组类型也可以通过字符代码引用，主要是为了保持与较旧的包（如Numeric）的向后兼容性。有些文档可能仍然引用这些，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=<span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">array([ <span class="number">1.</span>,  <span class="number">2.</span>,  <span class="number">3.</span>], dtype=float32)</span><br></pre></td></tr></table></figure>

<p>但我们仍然建议使用<code>dtype</code>对象。</p>
<p>要转换数组的类型，请使用 <code>.astype()</code> 方法（首选）或类型本身作为函数。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>z.astype(<span class="built_in">float</span>)                 </span><br><span class="line">array([  <span class="number">0.</span>,  <span class="number">1.</span>,  <span class="number">2.</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.int8(z)</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], dtype=int8)</span><br></pre></td></tr></table></figure>

<p>注意，在上面，我们使用 Python 的<code>float</code>对象作为<code>dtype</code>。NumPy中<code>int</code>是指<code>np.int_</code>，<code>bool</code>意味着<code>np.bool_</code>，<code>float</code>是<code>np.float_</code>，<code>complex</code>是<code>np.complex_</code>。其他数据类型没有Python等价物。</p>
<p>要确定数组的类型，请查看<code>dtype</code>属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>z.dtype</span><br><span class="line">dtype(<span class="string">&#x27;uint8&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p><code>dtype</code>对象还包含有关类型的信息，例如其位宽和字节顺序。数据类型也可以间接用于查询类型的属性，例如它是否为整数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = np.dtype(<span class="built_in">int</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d</span><br><span class="line">dtype(<span class="string">&#x27;int32&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.issubdtype(d, np.integer)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.issubdtype(d, np.floating)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h3 id="数组标量"><a href="#数组标量" class="headerlink" title="数组标量"></a>数组标量</h3><p>NumPy通常将数组元素作为数组标量返回（带有关联<code>dtype</code>的标量）。数组标量与Python标量不同，但在大多数情况下它们可以互换使用（主要的例外是早于v2.x的Python版本，其中整数数组标量不能作为列表和元组的索引）。有一些例外，例如当代码需要标量的非常特定的属性或者它特定地检查值是否是Python标量时。通常，存在的问题很容易被显式转换数组标量到Python标量，采用相应的Python类型的功能（例如，固定的<code>int</code>，<code>float</code>，<code>complex</code>，<code>str</code>，<code>unicode</code>）。</p>
<p>使用数组标量的主要优点是它们保留了数组类型（Python可能没有匹配的标量类型，例如int16）。因此，使用数组标量可确保数组和标量之间的相同行为，无论值是否在数组内。NumPy标量也有许多与数组相同的方法。</p>
<h3 id="溢出错误"><a href="#溢出错误" class="headerlink" title="溢出错误"></a>溢出错误</h3><p>当值需要比数据类型中的可用内存更多的内存时，NumPy数值类型的固定大小可能会导致溢出错误。例如，<code>numpy.power</code>对于int64可以正确计算 100 * 10 * 8，但对于int32给出1874919424（不正确）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.power(<span class="number">100</span>, <span class="number">8</span>, dtype=np.int64)</span><br><span class="line"><span class="number">10000000000000000</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.power(<span class="number">100</span>, <span class="number">8</span>, dtype=np.int32)</span><br><span class="line"><span class="number">1874919424</span></span><br></pre></td></tr></table></figure>

<p>NumPy和Python整数类型的行为在整数溢出方面存在显着差异，并且可能会使用户期望NumPy整数的行为类似于Python中的<code>int</code>。与 NumPy 不同，Python本体的<code>int</code>是灵活的。这意味着Python整数可以扩展以容纳任何整数并且不会溢出。</p>
<p>NumPy分别提供<code>numpy.iinfo</code>和<code>numpy.finfo</code>验证NumPy整数和浮点值的最小值或最大值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.iinfo(np.<span class="built_in">int</span>) <span class="comment"># Bounds of the default integer on this system.</span></span><br><span class="line">iinfo(<span class="built_in">min</span>=-<span class="number">9223372036854775808</span>, <span class="built_in">max</span>=<span class="number">9223372036854775807</span>, dtype=int64)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.iinfo(np.int32) <span class="comment"># Bounds of a 32-bit integer</span></span><br><span class="line">iinfo(<span class="built_in">min</span>=-<span class="number">2147483648</span>, <span class="built_in">max</span>=<span class="number">2147483647</span>, dtype=int32)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.iinfo(np.int64) <span class="comment"># Bounds of a 64-bit integer</span></span><br><span class="line">iinfo(<span class="built_in">min</span>=-<span class="number">9223372036854775808</span>, <span class="built_in">max</span>=<span class="number">9223372036854775807</span>, dtype=int64)</span><br></pre></td></tr></table></figure>

<p>如果int64仍然太小，则结果可能会转换为浮点数。浮点数提供了更大但不精确的可能值范围。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.power(<span class="number">100</span>, <span class="number">100</span>, dtype=np.int64) <span class="comment"># Incorrect even with 64-bit int</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.power(<span class="number">100</span>, <span class="number">100</span>, dtype=np.float64)</span><br><span class="line"><span class="number">1e+200</span></span><br></pre></td></tr></table></figure>

<h3 id="扩展精度"><a href="#扩展精度" class="headerlink" title="扩展精度"></a>扩展精度</h3><p>Python 的浮点数通常是64位浮点数，几乎等同于<code>np.float64</code>。在某些不寻常的情况下，使用更精确的浮点数可能会很有用。这在numpy中是否可行取决于硬件和开发环境：具体地说，x86机器提供80位精度的硬件浮点，虽然大多数C编译器提供这一点作为它们的<code>long double</code>类型，MSVC（Windows构建的标准）使<code>long double</code>等同于<code>double</code>（64位）。NumPy使编译器的<code>long double</code>作为<code>np.longdouble</code>可用（而<code>np.clongdouble</code>用于复数)。</p>
<p>NumPy不提供比C的<code>long double</code>更高精度的dtype；特别是128位IEEE四精度数据类型（FORTRAN的 <code>REAL*16</code> ）不可用。</p>
<p>为了有效地进行内存的校准，<code>np.longdouble</code>通常以零位进行填充，即96或者128位，哪个更有效率取决于硬件和开发环境；通常在32位系统上它们被填充到96位，而在64位系统上它们通常被填充到128位。<code>np.longdouble</code>被填充到系统默认值；为需要特定填充的用户提供了<code>np.float96</code>和<code>np.float128</code>。尽管它们的名称是这样叫的, 但是<code>np.float96</code>和<code>np.float128</code>只提供与<code>np.longdouble</code>一样的精度, 即大多数x86机器上的80位和标准Windows版本中的64位。</p>
<p>请注意，即使<code>np.longdouble</code>提供比Python中<code>float</code>更多的精度，也很容易失去额外的精度，因为Python通常强制值通过<code>float</code>传递值。</p>
<h2 id="数组索引"><a href="#数组索引" class="headerlink" title="数组索引"></a>数组索引</h2><p>NumPy提供了几种索引数组的方法。</p>
<h3 id="单元素索引"><a href="#单元素索引" class="headerlink" title="单元素索引"></a>单元素索引</h3><p>人们期望的是1-D数组的单元素索引。它的工作方式与其他标准Python序列完全相同。它从0开始计数，并接受从数组末尾开始索引的负索引。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.arange(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">2</span>]</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[-<span class="number">2</span>]</span><br><span class="line"><span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>与列表和元组不同，NumPy数组支持多维数组的多维索引。这意味着没有必要将每个维度的索引分成它自己的一组方括号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.shape = (<span class="number">2</span>,<span class="number">5</span>) <span class="comment"># now x is 2-dimensional</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">1</span>,<span class="number">3</span>]</span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line"><span class="number">9</span></span><br></pre></td></tr></table></figure>

<p>请注意，如果索引索引比维度少的多维数组，则会获得一个子维数组。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>]</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br></pre></td></tr></table></figure>

<p>也就是说，指定的每个索引选择与所选维度的其余部分对应的数组。在上面的示例中，选择0表示长度为5的剩余维度未指定，返回的是该维度和大小的数组。必须注意的是，返回的数组不是原始数据的副本，而是指向内存中与原始数组相同的值。在这种情况下，返回第一个位置（0）的1-D数组。因此，在返回的数组上使用单个索引会导致返回单个元素。那是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">0</span>][<span class="number">2</span>]</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>请注意，尽管第二种情况效率较低，因为在第一个索引之后创建了一个新的临时数组，该索引随后被索引为2：<code>x[0,2] = x[0][2]</code></p>
<h3 id="切片索引（Slicing）"><a href="#切片索引（Slicing）" class="headerlink" title="切片索引（Slicing）"></a>切片索引（Slicing）</h3><p>与Python列表类似，可以对NumPy数组进行切片。由于数组可能是多维的，因此必须为数组的每个维指定一个切片：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],     <span class="comment"># Create the following rank 2 array with shape (3, 4)</span></span><br><span class="line">              [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">              [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line">b = a[:<span class="number">2</span>, <span class="number">1</span>:<span class="number">3</span>]    <span class="comment"># Use slicing to pull out the subarray consisting of the first 2 rows and columns 1 and 2; </span></span><br><span class="line"><span class="built_in">print</span>(b)          <span class="comment"># b is the following array of shape (2, 2):</span></span><br><span class="line">                  <span class="comment"># [[2 3]</span></span><br><span class="line">                  <span class="comment">#  [6 7]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># A slice of an array is a view into the same data, so modifying it</span></span><br><span class="line"><span class="comment"># will modify the original array.</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">1</span>])   <span class="comment"># Prints &quot;2&quot;</span></span><br><span class="line">b[<span class="number">0</span>, <span class="number">0</span>] = <span class="number">77</span>     <span class="comment"># b[0, 0] is the same piece of data as a[0, 1]</span></span><br><span class="line"><span class="built_in">print</span>(a[<span class="number">0</span>, <span class="number">1</span>])   <span class="comment"># Prints &quot;77&quot;</span></span><br></pre></td></tr></table></figure>

<p>你还可以将整数索引与切片索引混合使用。 但是，这样做会产生比原始数组更低级别的数组。 请注意，这与MATLAB处理数组切片的方式完全不同：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">              [<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], </span><br><span class="line">              [<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Two ways of accessing the data in the middle row of the array.</span></span><br><span class="line"><span class="comment"># Mixing integer indexing with slices yields an array of lower rank,</span></span><br><span class="line"><span class="comment"># while using only slices yields an array of the same rank as the</span></span><br><span class="line"><span class="comment"># original array:</span></span><br><span class="line">row_r1 = a[<span class="number">1</span>, :]    <span class="comment"># Rank 1 view of the second row of a</span></span><br><span class="line">row_r2 = a[<span class="number">1</span>:<span class="number">2</span>, :]  <span class="comment"># Rank 2 view of the second row of a</span></span><br><span class="line"><span class="built_in">print</span>(row_r1, row_r1.shape)  <span class="comment"># Prints &quot;[5 6 7 8] (4,)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(row_r2, row_r2.shape)  <span class="comment"># Prints &quot;[[5 6 7 8]] (1, 4)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We can make the same distinction when accessing columns of an array:</span></span><br><span class="line">col_r1 = a[:, <span class="number">1</span>]</span><br><span class="line">col_r2 = a[:, <span class="number">1</span>:<span class="number">2</span>]</span><br><span class="line"><span class="built_in">print</span>(col_r1, col_r1.shape)  <span class="comment"># Prints &quot;[ 2  6 10] (3,)&quot;</span></span><br><span class="line"><span class="built_in">print</span>(col_r2, col_r2.shape)  <span class="comment"># Prints &quot;[[ 2]</span></span><br><span class="line">                             <span class="comment">#          [ 6]</span></span><br><span class="line">                             <span class="comment">#          [10]] (3, 1)&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="整数数组索引"><a href="#整数数组索引" class="headerlink" title="整数数组索引"></a>整数数组索引</h3><p>使用切片索引到NumPy数组时，生成的数组视图将始终是原始数组的子数组。 相反，整数数组索引允许你使用另一个数组中的数据构造任意数组。 这是一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">              [<span class="number">3</span>, <span class="number">4</span>], </span><br><span class="line">              [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># An example of integer array indexing.</span></span><br><span class="line"><span class="comment"># The returned array will have shape (3,) and</span></span><br><span class="line"><span class="built_in">print</span>(a[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>]])  <span class="comment"># Prints &quot;[1 4 5]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># The above example of integer array indexing is equivalent to this:</span></span><br><span class="line"><span class="built_in">print</span>(np.array([a[<span class="number">0</span>, <span class="number">0</span>], a[<span class="number">1</span>, <span class="number">1</span>], a[<span class="number">2</span>, <span class="number">0</span>]]))  <span class="comment"># Prints &quot;[1 4 5]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># When using integer array indexing, you can reuse the same</span></span><br><span class="line"><span class="comment"># element from the source array:</span></span><br><span class="line"><span class="built_in">print</span>(a[[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]])  <span class="comment"># Prints &quot;[2 2]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Equivalent to the previous integer array indexing example</span></span><br><span class="line"><span class="built_in">print</span>(np.array([a[<span class="number">0</span>, <span class="number">1</span>], a[<span class="number">0</span>, <span class="number">1</span>]]))  <span class="comment"># Prints &quot;[2 2]&quot;</span></span><br></pre></td></tr></table></figure>

<p>整数数组索引的一个有用技巧是从矩阵的每一行中选择或改变一个元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a new array from which we will select elements</span></span><br><span class="line">a = np.array([[ <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">              [ <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>], </span><br><span class="line">              [ <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>], </span><br><span class="line">              [<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create an array of indices</span></span><br><span class="line">b = np.array([<span class="number">0</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Select one element from each row of a using the indices in b</span></span><br><span class="line"><span class="built_in">print</span>(a[np.arange(<span class="number">4</span>), b])  <span class="comment"># Prints &quot;[ 1  6  7 11]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Mutate one element from each row of a using the indices in b</span></span><br><span class="line">a[np.arange(<span class="number">4</span>), b] += <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a)  <span class="comment"># prints &quot;array([[11,  2,  3],</span></span><br><span class="line">          <span class="comment">#                [ 4,  5, 16],</span></span><br><span class="line">          <span class="comment">#                [17,  8,  9],</span></span><br><span class="line">          <span class="comment">#                [10, 21, 12]])</span></span><br></pre></td></tr></table></figure>

<h3 id="布尔数组索引"><a href="#布尔数组索引" class="headerlink" title="布尔数组索引"></a>布尔数组索引</h3><p>布尔数组索引允许你选择数组的任意元素。通常，这种类型的索引用于选择满足某些条件的数组元素。下面是一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">bool_idx = (a &gt; <span class="number">2</span>)   <span class="comment"># Find the elements of a that are bigger than 2;</span></span><br><span class="line">                     <span class="comment"># this returns a numpy array of Booleans of the same</span></span><br><span class="line">                     <span class="comment"># shape as a, where each slot of bool_idx tells</span></span><br><span class="line">                     <span class="comment"># whether that element of a is &gt; 2.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(bool_idx)      <span class="comment"># Prints &quot;[[False False]</span></span><br><span class="line">                     <span class="comment">#          [ True  True]</span></span><br><span class="line">                     <span class="comment">#          [ True  True]]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We use boolean array indexing to construct a rank 1 array</span></span><br><span class="line"><span class="comment"># consisting of the elements of a corresponding to the True values</span></span><br><span class="line"><span class="comment"># of bool_idx</span></span><br><span class="line"><span class="built_in">print</span>(a[bool_idx])  <span class="comment"># Prints &quot;[3 4 5 6]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># We can do all of the above in a single concise statement:</span></span><br><span class="line"><span class="built_in">print</span>(a[a &gt; <span class="number">2</span>])     <span class="comment"># Prints &quot;[3 4 5 6]&quot;</span></span><br></pre></td></tr></table></figure>

<h2 id="广播-Broadcasting"><a href="#广播-Broadcasting" class="headerlink" title="广播(Broadcasting)"></a>广播(Broadcasting)</h2><p>广播是一种强大的机制，它允许NumPy在执行算术运算时使用不同形状的数组。通常，我们有一个较小的数组和一个较大的数组，我们希望多次使用较小的数组来对较大的数组执行一些操作。</p>
<p>例如，假设我们要向矩阵的每一行添加一个常数向量。我们可以这样做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># We will add the vector v to each row of the matrix x,</span></span><br><span class="line"><span class="comment"># storing the result in the matrix y</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = np.empty_like(x)   <span class="comment"># Create an empty matrix with the same shape as x</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the vector v to each row of the matrix x with an explicit loop</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line">    y[i, :] = x[i, :] + v</span><br><span class="line"></span><br><span class="line"><span class="comment"># Now y is the following</span></span><br><span class="line"><span class="comment"># [[ 2  2  4]</span></span><br><span class="line"><span class="comment">#  [ 5  5  7]</span></span><br><span class="line"><span class="comment">#  [ 8  8 10]</span></span><br><span class="line"><span class="comment">#  [11 11 13]]</span></span><br><span class="line"><span class="built_in">print</span>(y)</span><br></pre></td></tr></table></figure>

<p>这会凑效; 但是当矩阵 x 非常大时，在Python中计算显式循环可能会很慢。注意，向矩阵 x 的每一行添加向量 v 等同于通过垂直堆叠多个 v 副本来形成矩阵 vv，然后执行元素的求和x 和 vv。 我们可以像如下这样实现这种方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># We will add the vector v to each row of the matrix x,</span></span><br><span class="line"><span class="comment"># storing the result in the matrix y</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">vv = np.tile(v, (<span class="number">4</span>, <span class="number">1</span>))   <span class="comment"># Stack 4 copies of v on top of each other</span></span><br><span class="line"><span class="built_in">print</span>(vv)                 <span class="comment"># Prints &quot;[[1 0 1]</span></span><br><span class="line">                          <span class="comment">#          [1 0 1]</span></span><br><span class="line">                          <span class="comment">#          [1 0 1]</span></span><br><span class="line">                          <span class="comment">#          [1 0 1]]&quot;</span></span><br><span class="line">y = x + vv  <span class="comment"># Add x and vv elementwise</span></span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># Prints &quot;[[ 2  2  4</span></span><br><span class="line">          <span class="comment">#          [ 5  5  7]</span></span><br><span class="line">          <span class="comment">#          [ 8  8 10]</span></span><br><span class="line">          <span class="comment">#          [11 11 13]]&quot;</span></span><br></pre></td></tr></table></figure>

<p>NumPy广播允许我们在不实际创建v的多个副本的情况下执行此计算。考虑这个需求，使用广播如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># We will add the vector v to each row of the matrix x,</span></span><br><span class="line"><span class="comment"># storing the result in the matrix y</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>], [<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>], [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]])</span><br><span class="line">v = np.array([<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">y = x + v  <span class="comment"># Add v to each row of x using broadcasting</span></span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># Prints &quot;[[ 2  2  4]</span></span><br><span class="line">          <span class="comment">#          [ 5  5  7]</span></span><br><span class="line">          <span class="comment">#          [ 8  8 10]</span></span><br><span class="line">          <span class="comment">#          [11 11 13]]&quot;</span></span><br></pre></td></tr></table></figure>

<p>y&#x3D;x+v行即使x具有形状(4，3)和v具有形状(3,)，但由于广播的关系，该行的工作方式就好像v实际上具有形状(4，3)，其中每一行都是v的副本，并且求和是按元素执行的。</p>
<p>将两个数组一起广播遵循以下规则：</p>
<ul>
<li>如果数组不具有相同的rank，则将较低等级数组的形状添加1，直到两个形状具有相同的长度。</li>
<li>如果两个数组在维度上具有相同的大小，或者如果其中一个数组在该维度中的大小为1，则称这两个数组在维度上是兼容的。</li>
<li>如果数组在所有维度上兼容，则可以一起广播。</li>
<li>广播之后，每个数组的行为就好像它的形状等于两个输入数组的形状的元素最大值。</li>
<li>在一个数组的大小为1且另一个数组的大小大于1的任何维度中，第一个数组的行为就像沿着该维度复制一样</li>
</ul>
<p>支持广播的功能称为通用功能。</p>
<p>以下是广播的一些应用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># Compute outer product of vectors</span></span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])  <span class="comment"># v has shape (3,)</span></span><br><span class="line">w = np.array([<span class="number">4</span>,<span class="number">5</span>])    <span class="comment"># w has shape (2,)</span></span><br><span class="line"><span class="comment"># To compute an outer product, we first reshape v to be a column</span></span><br><span class="line"><span class="comment"># vector of shape (3, 1); we can then broadcast it against w to yield</span></span><br><span class="line"><span class="comment"># an output of shape (3, 2), which is the outer product of v and w:</span></span><br><span class="line"><span class="comment"># [[ 4  5]</span></span><br><span class="line"><span class="comment">#  [ 8 10]</span></span><br><span class="line"><span class="comment">#  [12 15]]</span></span><br><span class="line"><span class="built_in">print</span>(np.reshape(v, (<span class="number">3</span>, <span class="number">1</span>)) * w)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a vector to each row of a matrix</span></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="comment"># x has shape (2, 3) and v has shape (3,) so they broadcast to (2, 3),</span></span><br><span class="line"><span class="comment"># giving the following matrix:</span></span><br><span class="line"><span class="comment"># [[2 4 6]</span></span><br><span class="line"><span class="comment">#  [5 7 9]]</span></span><br><span class="line"><span class="built_in">print</span>(x + v)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add a vector to each column of a matrix</span></span><br><span class="line"><span class="comment"># x has shape (2, 3) and w has shape (2,).</span></span><br><span class="line"><span class="comment"># If we transpose x then it has shape (3, 2) and can be broadcast</span></span><br><span class="line"><span class="comment"># against w to yield a result of shape (3, 2); transposing this result</span></span><br><span class="line"><span class="comment"># yields the final result of shape (2, 3) which is the matrix x with</span></span><br><span class="line"><span class="comment"># the vector w added to each column. Gives the following matrix:</span></span><br><span class="line"><span class="comment"># [[ 5  6  7]</span></span><br><span class="line"><span class="comment">#  [ 9 10 11]]</span></span><br><span class="line"><span class="built_in">print</span>((x.T + w).T)</span><br><span class="line"><span class="comment"># Another solution is to reshape w to be a column vector of shape (2, 1);</span></span><br><span class="line"><span class="comment"># we can then broadcast it directly against x to produce the same</span></span><br><span class="line"><span class="comment"># output.</span></span><br><span class="line"><span class="built_in">print</span>(x + np.reshape(w, (<span class="number">2</span>, <span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Multiply a matrix by a constant:</span></span><br><span class="line"><span class="comment"># x has shape (2, 3). Numpy treats scalars as arrays of shape ();</span></span><br><span class="line"><span class="comment"># these can be broadcast together to shape (2, 3), producing the</span></span><br><span class="line"><span class="comment"># following array:</span></span><br><span class="line"><span class="comment"># [[ 2  4  6]</span></span><br><span class="line"><span class="comment">#  [ 8 10 12]]</span></span><br><span class="line"><span class="built_in">print</span>(x * <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>广播通常会使你的代码更简洁，效率更高，因此你应该尽可能地使用它。</p>
<h2 id="数组中的基本数学"><a href="#数组中的基本数学" class="headerlink" title="数组中的基本数学"></a>数组中的基本数学</h2><p>基本数学函数在数组上以元素方式运行，既可以作为运算符重载，也可以作为NumPy模块中的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]], dtype=np.float64)</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]], dtype=np.float64)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise sum; both produce the array</span></span><br><span class="line"><span class="comment"># [[ 6.0  8.0]</span></span><br><span class="line"><span class="comment">#  [10.0 12.0]]</span></span><br><span class="line"><span class="built_in">print</span>(x + y)</span><br><span class="line"><span class="built_in">print</span>(np.add(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise difference; both produce the array</span></span><br><span class="line"><span class="comment"># [[-4.0 -4.0]</span></span><br><span class="line"><span class="comment">#  [-4.0 -4.0]]</span></span><br><span class="line"><span class="built_in">print</span>(x - y)</span><br><span class="line"><span class="built_in">print</span>(np.subtract(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise product; both produce the array</span></span><br><span class="line"><span class="comment"># [[ 5.0 12.0]</span></span><br><span class="line"><span class="comment">#  [21.0 32.0]]</span></span><br><span class="line"><span class="built_in">print</span>(x * y)</span><br><span class="line"><span class="built_in">print</span>(np.multiply(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise division; both produce the array</span></span><br><span class="line"><span class="comment"># [[ 0.2         0.33333333]</span></span><br><span class="line"><span class="comment">#  [ 0.42857143  0.5       ]]</span></span><br><span class="line"><span class="built_in">print</span>(x / y)</span><br><span class="line"><span class="built_in">print</span>(np.divide(x, y))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Elementwise square root; produces the array</span></span><br><span class="line"><span class="comment"># [[ 1.          1.41421356]</span></span><br><span class="line"><span class="comment">#  [ 1.73205081  2.        ]]</span></span><br><span class="line"><span class="built_in">print</span>(np.sqrt(x))</span><br></pre></td></tr></table></figure>

<p>请注意，与MATLAB不同，<code>*</code>是元素乘法，而不是矩阵乘法。 我们使用<code>dot</code>函数来计算向量的内积，将向量乘以矩阵。 <code>dot</code>既可以作为NumPy模块中的函数，也可以作为数组对象的实例方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line">y = np.array([[<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]])</span><br><span class="line"></span><br><span class="line">v = np.array([<span class="number">9</span>,<span class="number">10</span>])</span><br><span class="line">w = np.array([<span class="number">11</span>, <span class="number">12</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Inner product of vectors; both produce 219</span></span><br><span class="line"><span class="built_in">print</span>(v.dot(w))</span><br><span class="line"><span class="built_in">print</span>(np.dot(v, w))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Matrix / vector product; both produce the rank 1 array [29 67]</span></span><br><span class="line"><span class="built_in">print</span>(x.dot(v))</span><br><span class="line"><span class="built_in">print</span>(np.dot(x, v))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Matrix / matrix product; both produce the rank 2 array</span></span><br><span class="line"><span class="comment"># [[19 22]</span></span><br><span class="line"><span class="comment">#  [43 50]]</span></span><br><span class="line"><span class="built_in">print</span>(x.dot(y))</span><br><span class="line"><span class="built_in">print</span>(np.dot(x, y))</span><br></pre></td></tr></table></figure>

<p>NumPy为在数组上执行计算提供了许多有用的函数；其中最常用的函数之一是求和函数<code>sum</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(x))  <span class="comment"># Compute sum of all elements; prints &quot;10&quot;</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(x, axis=<span class="number">0</span>))  <span class="comment"># Compute sum of each column; prints &quot;[4 6]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(np.<span class="built_in">sum</span>(x, axis=<span class="number">1</span>))  <span class="comment"># Compute sum of each row; prints &quot;[3 7]&quot;</span></span><br></pre></td></tr></table></figure>


<p>除了使用数组计算数学函数外，我们经常需要对数组中的数据进行整形或其他操作。这种操作的最简单的例子是转置一个矩阵；要转置一个矩阵，只需使用一个数组对象的T属性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.array([[<span class="number">1</span>,<span class="number">2</span>], [<span class="number">3</span>,<span class="number">4</span>]])</span><br><span class="line"><span class="built_in">print</span>(x)    <span class="comment"># Prints &quot;[[1 2]</span></span><br><span class="line">            <span class="comment">#          [3 4]]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(x.T)  <span class="comment"># Prints &quot;[[1 3]</span></span><br><span class="line">            <span class="comment">#          [2 4]]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Note that taking the transpose of a rank 1 array does nothing:</span></span><br><span class="line">v = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line"><span class="built_in">print</span>(v)    <span class="comment"># Prints &quot;[1 2 3]&quot;</span></span><br><span class="line"><span class="built_in">print</span>(v.T)  <span class="comment"># Prints &quot;[1 2 3]&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="点积运算原理"><a href="#点积运算原理" class="headerlink" title="点积运算原理"></a>点积运算原理</h3><h4 id="数组特殊运算符"><a href="#数组特殊运算符" class="headerlink" title="数组特殊运算符"></a>数组特殊运算符</h4><p>NumPy还提供了一些别的用于处理数组的好用的运算符。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dot, sum, min, max, cumsum</span></span><br><span class="line">a = np.arange(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">sum</span>()) <span class="comment"># &gt;&gt;&gt;45</span></span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">min</span>()) <span class="comment"># &gt;&gt;&gt;0</span></span><br><span class="line"><span class="built_in">print</span>(a.<span class="built_in">max</span>()) <span class="comment"># &gt;&gt;&gt;9</span></span><br><span class="line"><span class="built_in">print</span>(a.cumsum()) <span class="comment"># &gt;&gt;&gt;[ 0  1  3  6 10 15 21 28 36 45]</span></span><br></pre></td></tr></table></figure>

<p>sum()、min()和max()函数的作用非常明显。将所有元素相加，找出最小和最大元素。</p>
<p>然而，cumsum()函数就不那么明显了。它将像sum()这样的每个元素相加，但是它首先将第一个元素和第二个元素相加，并将计算结果存储在一个列表中，然后将该结果添加到第三个元素中，然后再将该结果存储在一个列表中。这将对数组中的所有元素执行此操作，并返回作为列表的数组之和的运行总数。</p>
<h4 id="Where-函数"><a href="#Where-函数" class="headerlink" title="Where 函数"></a>Where 函数</h4><p>where() 函数是一个根据条件返回数组中的值的有效方法。只需要把条件传递给它，它就会返回一个使得条件为真的元素的列表。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Where</span></span><br><span class="line">a = np.arange(<span class="number">0</span>, <span class="number">100</span>, <span class="number">10</span>)</span><br><span class="line">b = np.where(a &lt; <span class="number">50</span>) </span><br><span class="line">c = np.where(a &gt;= <span class="number">50</span>)[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(b) <span class="comment"># &gt;&gt;&gt;(array([0, 1, 2, 3, 4]),)</span></span><br><span class="line"><span class="built_in">print</span>(c) <span class="comment"># &gt;&gt;&gt;[5 6 7 8 9]</span></span><br></pre></td></tr></table></figure>


<h2 id="字节交换"><a href="#字节交换" class="headerlink" title="字节交换"></a>字节交换</h2><h3 id="字节排序和ndarrays简介"><a href="#字节排序和ndarrays简介" class="headerlink" title="字节排序和ndarrays简介"></a>字节排序和ndarrays简介</h3><p>ndarray是一个为内存中的数据提供python数组接口的对象。经常发生的情况是，要用数组查看的内存与运行Python的计算机的字节顺序不同。</p>
<p>例如，我可能正在使用带有 little-endian CPU 的计算机 - 例如Intel Pentium，但是我已经从一个由 big-endian计算机 编写的文件中加载了一些数据。假设我已经从Sun（big-endian）计算机写入的文件中加载了4个字节。我知道这4个字节代表两个16位整数。在 big-endian 机器上，首先以最高有效字节（MSB）存储双字节整数，然后存储最低有效字节（LSB）。因此字节按内存顺序排列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MSB整数<span class="number">1</span></span><br><span class="line">LSB整数<span class="number">1</span></span><br><span class="line">MSB整数<span class="number">2</span></span><br><span class="line">LSB整数<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>假设两个整数实际上是1和770.因为770 &#x3D; 256 * 3 + 2，内存中的4个字节将分别包含：0,1,3,2。我从文件加载的字节将包含这些内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>big_end_buffer = <span class="built_in">bytearray</span>([<span class="number">0</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>big_end_buffer</span><br><span class="line"><span class="built_in">bytearray</span>(<span class="string">b&#x27;\x00\x01\x03\x02&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>我们可能需要使用 ndarray 来访问这些整数。在这种情况下，我们可以围绕这个内存创建一个数组，并告诉numpy有两个整数，并且它们是16位和Big-endian：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>big_end_arr = np.ndarray(shape=(<span class="number">2</span>,),dtype=<span class="string">&#x27;&gt;i2&#x27;</span>, buffer=big_end_buffer)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>big_end_arr[<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>big_end_arr[<span class="number">1</span>]</span><br><span class="line"><span class="number">770</span></span><br></pre></td></tr></table></figure>

<p>注意上面的数组<code>dtype &gt; i2</code>。<code>&gt;</code> 表示 big-endian( <code>&lt;</code> 是 Little-endian )，i2 表示‘有符号的2字节整数’。例如，如果我们的数据表示单个无符号4字节小端整数，则dtype字符串将为 <code>&lt;u4</code>。</p>
<p>事实上，为什么我们不尝试呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>little_end_u4 = np.ndarray(shape=(<span class="number">1</span>,),dtype=<span class="string">&#x27;&lt;u4&#x27;</span>, buffer=big_end_buffer)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>little_end_u4[<span class="number">0</span>] == <span class="number">1</span> * <span class="number">256</span>**<span class="number">1</span> + <span class="number">3</span> * <span class="number">256</span>**<span class="number">2</span> + <span class="number">2</span> * <span class="number">256</span>**<span class="number">3</span></span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p>回到我们的 big_end_arr - 在这种情况下我们的基础数据是big-endian（数据字节序），我们设置dtype匹配（dtype也是big-endian）。但是，有时你需要翻转它们。</p>
<p>标量当前不包含字节顺序信息，因此从数组中提取标量将返回本机字节顺序的整数。因此：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>big_end_arr[<span class="number">0</span>].dtype.byteorder == little_end_u4[<span class="number">0</span>].dtype.byteorder</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h3 id="更改字节顺序"><a href="#更改字节顺序" class="headerlink" title="更改字节顺序"></a>更改字节顺序</h3><p>从介绍中可以想象，有两种方法可以影响数组的字节顺序与它所查看的底层内存之间的关系：</p>
<ul>
<li><p>更改数组dtype中的字节顺序信息，以便将基础数据解释为不同的字节顺序。这是作用 <code>arr.newbyteorder()</code></p>
</li>
<li><p>更改基础数据的字节顺序，保留<code>dtype</code>解释。这是做什么的 <code>arr.byteswap()</code>。</p>
</li>
</ul>
<p>需要更改字节顺序的常见情况是：</p>
<ul>
<li>数据和dtype字节顺序不匹配，并且希望更改dtype以使其与数据匹配。</li>
<li>数据和dtype字节顺序不匹配，并且希望交换数据以使它们与dtype匹配</li>
<li>数据和dtype字节顺序匹配，但希望交换数据和dtype来反映这一点</li>
</ul>
<h4 id="数据和dtype字节顺序不匹配，更改dtype以匹配数据"><a href="#数据和dtype字节顺序不匹配，更改dtype以匹配数据" class="headerlink" title="数据和dtype字节顺序不匹配，更改dtype以匹配数据"></a>数据和dtype字节顺序不匹配，更改dtype以匹配数据</h4><p>我们制作一些他们不匹配的东西：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>wrong_end_dtype_arr = np.ndarray(shape=(<span class="number">2</span>,),dtype=<span class="string">&#x27;&lt;i2&#x27;</span>, buffer=big_end_buffer)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>wrong_end_dtype_arr[<span class="number">0</span>]</span><br><span class="line"><span class="number">256</span></span><br></pre></td></tr></table></figure>

<p>这种情况的明显解决方法是更改dtype，以便它给出正确的字节顺序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fixed_end_dtype_arr = wrong_end_dtype_arr.newbyteorder()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fixed_end_dtype_arr[<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>请注意，内存中的数组未更改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fixed_end_dtype_arr.tobytes() == big_end_buffer</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<h4 id="数据和类型字节顺序不匹配，更改数据以匹配dtype"><a href="#数据和类型字节顺序不匹配，更改数据以匹配dtype" class="headerlink" title="数据和类型字节顺序不匹配，更改数据以匹配dtype"></a>数据和类型字节顺序不匹配，更改数据以匹配dtype</h4><p>如果需要内存中的数据是某种顺序，可能希望这样做。例如，可能正在将内存写入需要特定字节排序的文件。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fixed_end_mem_arr = wrong_end_dtype_arr.byteswap()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fixed_end_mem_arr[<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>现在数组 已 在内存中更改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fixed_end_mem_arr.tobytes() == big_end_buffer</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<h4 id="数据和dtype字节序匹配，交换数据和dtype"><a href="#数据和dtype字节序匹配，交换数据和dtype" class="headerlink" title="数据和dtype字节序匹配，交换数据和dtype"></a>数据和dtype字节序匹配，交换数据和dtype</h4><p>可能有一个正确指定的数组dtype，但是需要数组在内存中具有相反的字节顺序，并且希望dtype匹配以便数组值有意义。在这种情况下，只需执行上述两个操作：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>swapped_end_arr = big_end_arr.byteswap().newbyteorder()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>swapped_end_arr[<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>swapped_end_arr.tobytes() == big_end_buffer</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>使用ndarray astype方法可以更简单地将数据转换为特定的dtype和字节顺序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>swapped_end_arr = big_end_arr.astype(<span class="string">&#x27;&lt;i2&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>swapped_end_arr[<span class="number">0</span>]</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>swapped_end_arr.tobytes() == big_end_buffer</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>


<h2 id="结构化数组"><a href="#结构化数组" class="headerlink" title="结构化数组"></a>结构化数组</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>结构化数组是ndarray，其数据类型是由一系列命名字段组织的简单数据类型组成。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.array([(<span class="string">&#x27;Rex&#x27;</span>, <span class="number">9</span>, <span class="number">81.0</span>), (<span class="string">&#x27;Fido&#x27;</span>, <span class="number">3</span>, <span class="number">27.0</span>)],</span><br><span class="line"><span class="meta">... </span>             dtype=[(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;U10&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;i4&#x27;</span>), (<span class="string">&#x27;weight&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([(<span class="string">&#x27;Rex&#x27;</span>, <span class="number">9</span>, <span class="number">81.</span>), (<span class="string">&#x27;Fido&#x27;</span>, <span class="number">3</span>, <span class="number">27.</span>)],</span><br><span class="line">      dtype=[(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;U10&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;&lt;i4&#x27;</span>), (<span class="string">&#x27;weight&#x27;</span>, <span class="string">&#x27;&lt;f4&#x27;</span>)])</span><br></pre></td></tr></table></figure>

<p>x 是一个长度为2的一维数组，其数据类型是一个包含三个字段的结构：</p>
<ul>
<li>长度为10或更少的字符串，名为“name”。</li>
<li>一个32位整数，名为“age”。</li>
<li>一个32位的名为’weight’的float类型。</li>
</ul>
<p>如果x在位置1处索引，则会得到一个结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">1</span>]</span><br><span class="line">(<span class="string">&#x27;Fido&#x27;</span>, <span class="number">3</span>, <span class="number">27.0</span>)</span><br></pre></td></tr></table></figure>

<p>可以通过使用字段名称建立索引来访问和修改结构化数组的各个字段：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="string">&#x27;age&#x27;</span>]</span><br><span class="line">array([<span class="number">9</span>, <span class="number">3</span>], dtype=int32)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="string">&#x27;age&#x27;</span>] = <span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([(<span class="string">&#x27;Rex&#x27;</span>, <span class="number">5</span>, <span class="number">81.</span>), (<span class="string">&#x27;Fido&#x27;</span>, <span class="number">5</span>, <span class="number">27.</span>)],</span><br><span class="line">      dtype=[(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;U10&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;&lt;i4&#x27;</span>), (<span class="string">&#x27;weight&#x27;</span>, <span class="string">&#x27;&lt;f4&#x27;</span>)])</span><br></pre></td></tr></table></figure>

<p>结构化数据类型旨在能够模仿C语言中的“结构”，并共享类似的内存布局。它们用于连接C代码和低级操作结构化缓冲区，例如用于解释二进制blob。出于这些目的，它们支持诸如子数组，嵌套数据类型和联合之类的专用功能，并允许控制结构的内存布局。</p>
<p>希望操纵表格数据的用户（例如存储在csv文件中）可能会发现其他更适合的pydata项目，例如xarray，pandas或DataArray。这些为表格数据分析提供了高级接口，并且针对该用途进行了更好的优化。例如，numpy中结构化数组的类似C-struct的内存布局可能导致较差的缓存行为。</p>
<h3 id="结构化数据类型创建"><a href="#结构化数据类型创建" class="headerlink" title="结构化数据类型创建"></a>结构化数据类型创建</h3><p>结构化数据类型可以被认为是一定长度的字节序列（结构的项目大小），它被解释为字段集合。每个字段在结构中都有一个名称，一个数据类型和一个字节偏移量。字段的数据类型可以是包括其他结构化数据类型的任何numpy数据类型，也可以是子行数据类型，其行为类似于指定形状的ndarray。字段的偏移是任意的，字段甚至可以重叠。这些偏移量通常由numpy自动确定，但也可以指定。</p>
<p>可以使用该函数创建结构化数据类型numpy.dtype。有4种不同的规范形式， 其灵活性和简洁性各不相同。这些在 “数据类型对象” 参考页面中进一步记录，总结如下：</p>
<h4 id="元组列表，每个字段一个元组"><a href="#元组列表，每个字段一个元组" class="headerlink" title="元组列表，每个字段一个元组"></a>元组列表，每个字段一个元组</h4><p>每个元组都具有以下形式（字段名称、数据类型、形状），其中Shape是可选的。 fieldname 是字符串（如果使用标题，则为元组，请参见下面的字段标题）， datatype 可以是任何可转换为数据类型的对象，而 shape 是指定子数组形状的整数元组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.dtype([(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>), (<span class="string">&#x27;y&#x27;</span>, np.float32), (<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>, (<span class="number">2</span>, <span class="number">2</span>))])</span><br><span class="line">dtype([(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;&lt;f4&#x27;</span>), (<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;&lt;f4&#x27;</span>), (<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;&lt;f4&#x27;</span>, (<span class="number">2</span>, <span class="number">2</span>))])</span><br></pre></td></tr></table></figure>

<p>如果 fieldname 是空字符串 ‘’ ，则将为字段指定格式为 f# 的默认名称， 其中 # 是字段的整数索引，从左侧开始从0开始计数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.dtype([(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>), (<span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;i4&#x27;</span>), (<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;i8&#x27;</span>)])</span><br><span class="line">dtype([(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;&lt;f4&#x27;</span>), (<span class="string">&#x27;f1&#x27;</span>, <span class="string">&#x27;&lt;i4&#x27;</span>), (<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;&lt;i8&#x27;</span>)])</span><br></pre></td></tr></table></figure>

<p>自动确定结构内字段的字节偏移量和总结构项大小。</p>
<h4 id="逗号分隔的数据类型规范字符串"><a href="#逗号分隔的数据类型规范字符串" class="headerlink" title="逗号分隔的数据类型规范字符串"></a>逗号分隔的数据类型规范字符串</h4><p>在这个速记符号中，任何 字符串dtype规范 都可以在字符串中使用， 并用逗号分隔。 字段的项目大小和字节偏移是自动确定的，并且字段名称被赋予默认名称 f0、f1等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.dtype(<span class="string">&#x27;i8, f4, S3&#x27;</span>)</span><br><span class="line">dtype([(<span class="string">&#x27;f0&#x27;</span>, <span class="string">&#x27;&lt;i8&#x27;</span>), (<span class="string">&#x27;f1&#x27;</span>, <span class="string">&#x27;&lt;f4&#x27;</span>), (<span class="string">&#x27;f2&#x27;</span>, <span class="string">&#x27;S3&#x27;</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.dtype(<span class="string">&#x27;3int8, float32, (2, 3)float64&#x27;</span>)</span><br><span class="line">dtype([(<span class="string">&#x27;f0&#x27;</span>, <span class="string">&#x27;i1&#x27;</span>, (<span class="number">3</span>,)), (<span class="string">&#x27;f1&#x27;</span>, <span class="string">&#x27;&lt;f4&#x27;</span>), (<span class="string">&#x27;f2&#x27;</span>, <span class="string">&#x27;&lt;f8&#x27;</span>, (<span class="number">2</span>, <span class="number">3</span>))])</span><br></pre></td></tr></table></figure>

<h4 id="字段参数组字典"><a href="#字段参数组字典" class="headerlink" title="字段参数组字典"></a>字段参数组字典</h4><p>这是最灵活的规范形式，因为它允许控制字段的字节偏移和结构的项目大小。</p>
<p>字典有两个必需键 “names” 和 “format”，以及四个可选键 “offsets”、“itemsize”、“Aligned” 和 “title”。 名称和格式的值应该分别是相同长度的字段名列表和dtype规范列表。 可选的 “offsets” 值应该是整数字节偏移量的列表，结构中的每个字段都有一个偏移量。 如果未给出 “Offsets” ，则自动确定偏移量。可选的 “itemsize” 值应该是一个整数， 描述dtype的总大小（以字节为单位），它必须足够大以包含所有字段。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.dtype(&#123;<span class="string">&#x27;names&#x27;</span>: [<span class="string">&#x27;col1&#x27;</span>, <span class="string">&#x27;col2&#x27;</span>], <span class="string">&#x27;formats&#x27;</span>: [<span class="string">&#x27;i4&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>]&#125;)</span><br><span class="line">dtype([(<span class="string">&#x27;col1&#x27;</span>, <span class="string">&#x27;&lt;i4&#x27;</span>), (<span class="string">&#x27;col2&#x27;</span>, <span class="string">&#x27;&lt;f4&#x27;</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.dtype(&#123;<span class="string">&#x27;names&#x27;</span>: [<span class="string">&#x27;col1&#x27;</span>, <span class="string">&#x27;col2&#x27;</span>],</span><br><span class="line"><span class="meta">... </span>          <span class="string">&#x27;formats&#x27;</span>: [<span class="string">&#x27;i4&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>],</span><br><span class="line"><span class="meta">... </span>          <span class="string">&#x27;offsets&#x27;</span>: [<span class="number">0</span>, <span class="number">4</span>],</span><br><span class="line"><span class="meta">... </span>          <span class="string">&#x27;itemsize&#x27;</span>: <span class="number">12</span>&#125;)</span><br><span class="line">dtype(&#123;<span class="string">&#x27;names&#x27;</span>:[<span class="string">&#x27;col1&#x27;</span>,<span class="string">&#x27;col2&#x27;</span>], <span class="string">&#x27;formats&#x27;</span>:[<span class="string">&#x27;&lt;i4&#x27;</span>,<span class="string">&#x27;&lt;f4&#x27;</span>], <span class="string">&#x27;offsets&#x27;</span>:[<span class="number">0</span>,<span class="number">4</span>], <span class="string">&#x27;itemsize&#x27;</span>:<span class="number">12</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>可以选择偏移量，使得字段重叠，尽管这将意味着分配给一个字段可能会破坏任何重叠字段的数据。 作为一个例外，numpy.object类型的字段不能与其他字段重叠，因为存在破坏内部对象指针然后取消引用它的风险。</p>
<p>可选的“Aligned”值可以设置为True，以使自动偏移计算使用对齐的偏移量（请参阅自动字节偏移量和对齐）， 就好像numpy.dtype的“Align”关键字参数已设置为True一样。</p>
<p>可选的 ‘titles’ 值应该是长度与 ‘names’ 相同的标题列表，请参阅下面的字段标题。</p>
<h4 id="字段名称字典"><a href="#字段名称字典" class="headerlink" title="字段名称字典"></a>字段名称字典</h4><p>不鼓励使用这种形式的规范。 字典的关键字是字段名称，值是指定类型和偏移量的元组：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.dtype(&#123;<span class="string">&#x27;col1&#x27;</span>: (<span class="string">&#x27;i1&#x27;</span>, <span class="number">0</span>), <span class="string">&#x27;col2&#x27;</span>: (<span class="string">&#x27;f4&#x27;</span>, <span class="number">1</span>)&#125;)</span><br><span class="line">dtype([(<span class="string">&#x27;col1&#x27;</span>, <span class="string">&#x27;i1&#x27;</span>), (<span class="string">&#x27;col2&#x27;</span>, <span class="string">&#x27;&lt;f4&#x27;</span>)])</span><br></pre></td></tr></table></figure>

<p>不鼓励使用这种形式，因为Python字典在Python 3.6之前的Python版本中不保留顺序， 并且结构化dtype中字段的顺序有意义。字段标题可以通过使用3元组来指定，见下文。</p>
<h3 id="操作和显示结构化数据类型"><a href="#操作和显示结构化数据类型" class="headerlink" title="操作和显示结构化数据类型"></a>操作和显示结构化数据类型</h3><p>可以names 在dtype对象的属性中找到结构化数据类型的字段名称列表：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d = np.dtype([(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;i8&#x27;</span>), (<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.names</span><br><span class="line">(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>可以通过names使用相同长度的字符串序列分配属性来修改字段名称。</p>
<p>dtype对象还具有类似字典的属性，fields其键是字段名称（和字段标题，见下文）， 其值是包含每个字段的dtype和字节偏移量的元组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>d.fields</span><br><span class="line">mappingproxy(&#123;<span class="string">&#x27;x&#x27;</span>: (dtype(<span class="string">&#x27;int64&#x27;</span>), <span class="number">0</span>), <span class="string">&#x27;y&#x27;</span>: (dtype(<span class="string">&#x27;float32&#x27;</span>), <span class="number">8</span>)&#125;)</span><br></pre></td></tr></table></figure>

<p>对于非结构化数组，names和fields属性都相同None。 测试 dtype 是否结构化的推荐方法是， 如果dt.names不是None 而不是 dt.names ，则考虑具有0字段的dtypes。</p>
<p>如果可能，结构化数据类型的字符串表示形式显示在“元组列表”表单中，否则numpy将回退到使用更通用的字典表单。</p>
<h3 id="自动字节偏移和对齐"><a href="#自动字节偏移和对齐" class="headerlink" title="自动字节偏移和对齐"></a>自动字节偏移和对齐</h3><p>NumPy使用两种方法之一自动确定字段字节偏移量和结构化数据类型的总项目大小，具体取决于是否 align&#x3D;True指定为关键字参数numpy.dtype。</p>
<p>默认情况下（align&#x3D;False），numpy将字段打包在一起，使得每个字段从前一个字段结束的字节偏移开始，并且字段在内存中是连续的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">def</span> <span class="title function_">print_offsets</span>(<span class="params">d</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;offsets:&quot;</span>, [d.fields[name][<span class="number">1</span>] <span class="keyword">for</span> name <span class="keyword">in</span> d.names])</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(<span class="string">&quot;itemsize:&quot;</span>, d.itemsize)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_offsets(np.dtype(<span class="string">&#x27;u1, u1, i4, u1, i8, u2&#x27;</span>))</span><br><span class="line">offsets: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">15</span>]</span><br><span class="line">itemsize: <span class="number">17</span></span><br></pre></td></tr></table></figure>

<p>如果align&#x3D;True设置了，NumPy将以与许多C编译器填充C结构相同的方式填充结构。在某些情况下，对齐结构可以提高性能，但代价是增加了数据类型的大小。在字段之间插入填充字节，使得每个字段的字节偏移量将是该字段对齐的倍数，对于简单数据类型，通常等于字段的字节大小，请参阅PyArray_Descr.alignment。该结构还将添加尾随填充，以使其itemsize是最大字段对齐的倍数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print_offsets(np.dtype(<span class="string">&#x27;u1, u1, i4, u1, i8, u2&#x27;</span>, align=<span class="literal">True</span>))</span><br><span class="line">offsets: [<span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">24</span>]</span><br><span class="line">itemsize: <span class="number">32</span></span><br></pre></td></tr></table></figure>

<p>请注意，尽管默认情况下几乎所有现代C编译器都以这种方式填充，但C结构中的填充依赖于C实现，因此不能保证此内存布局与C程序中相应结构的内容完全匹配。为了获得确切的对应关系，可能需要在numpy侧或C侧进行一些工作。</p>
<p>如果使用offsets基于字典的dtype规范中的可选键指定了偏移量，则设置align&#x3D;True将检查每个字段的偏移量是其大小的倍数，并且itemsize是最大字段大小的倍数，如果不是，则引发异常。</p>
<p>如果结构化数组的字段和项目大小的偏移满足对齐条件，则数组将具有该ALIGNED flag集合。</p>
<p>便捷函数<code>numpy.lib.recfunctions.repack_fields</code>将对齐的dtype或数组转换为打包的dtype或数组，反之亦然。它需要一个dtype或结构化的ndarray作为参数，并返回一个带有字段重新打包的副本，带或不带填充字节。</p>
<h3 id="字段标题"><a href="#字段标题" class="headerlink" title="字段标题"></a>字段标题</h3><p>除了字段名称之外，字段还可以具有关联的标题，备用名称，有时用作字段的附加说明或别名。标题可用于索引数组，就像字段名一样。</p>
<p>要在使用dtype规范的list-of-tuples形式时添加标题，可以将字段名称指定为两个字符串的元组而不是单个字符串，它们分别是字段的标题和字段名称。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.dtype([((<span class="string">&#x27;my title&#x27;</span>, <span class="string">&#x27;name&#x27;</span>), <span class="string">&#x27;f4&#x27;</span>)])</span><br><span class="line">dtype([((<span class="string">&#x27;my title&#x27;</span>, <span class="string">&#x27;name&#x27;</span>), <span class="string">&#x27;&lt;f4&#x27;</span>)])</span><br></pre></td></tr></table></figure>

<p>当使用第一种形式的基于字典的规范时，标题可以’titles’作为如上所述的额外密钥提供。当使用第二个（不鼓励的）基于字典的规范时，可以通过提供3元素元组而不是通常的2元素元组来提供标题：(datatype, offset, title)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.dtype(&#123;<span class="string">&#x27;name&#x27;</span>: (<span class="string">&#x27;i4&#x27;</span>, <span class="number">0</span>, <span class="string">&#x27;my title&#x27;</span>)&#125;)</span><br><span class="line">dtype([((<span class="string">&#x27;my title&#x27;</span>, <span class="string">&#x27;name&#x27;</span>), <span class="string">&#x27;&lt;i4&#x27;</span>)])</span><br></pre></td></tr></table></figure>

<p>该dtype.fields字典将包含标题作为键，如果使用任何头衔。这有效地表示具有标题的字段将在字典字典中表示两次。这些字段的元组值还将具有第三个元素，即字段标题。因此，并且因为names属性保留了字段顺序而fields 属性可能没有，所以建议使用dtype的names属性迭代dtype的字段，该属性不会列出标题，如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name <span class="keyword">in</span> d.names:</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(d.fields[name][:<span class="number">2</span>])</span><br><span class="line">(dtype(<span class="string">&#x27;int64&#x27;</span>), <span class="number">0</span>)</span><br><span class="line">(dtype(<span class="string">&#x27;float32&#x27;</span>), <span class="number">8</span>)</span><br></pre></td></tr></table></figure>

<h3 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h3><p>默认情况下，结构化数据类型在numpy中实现为基本类型 numpy.void， 但是可以使用 数据类型对象中 中描述的dtype规范的 (base_dtype, dtype) 形式将其他 numpy 类型解释为结构化类型。 这里，base_dtype 是所需的底层 dtype，字段和标志将从dtype复制。此 dtype 类似于 C 中的“Union”。</p>
<h3 id="将数据分配给结构化数组"><a href="#将数据分配给结构化数组" class="headerlink" title="将数据分配给结构化数组"></a>将数据分配给结构化数组</h3><p>有许多方法可以为结构化数组赋值：使用python元组，使用标量值或使用其他结构化数组。</p>
<h4 id="从Python本机类型（元组）分配"><a href="#从Python本机类型（元组）分配" class="headerlink" title="从Python本机类型（元组）分配"></a>从Python本机类型（元组）分配</h4><p>为结构化数组赋值的最简单方法是使用python元组。每个赋值应该是一个长度等于数组中字段数的元组，而不是列表或数组，因为它们将触发numpy的广播规则。元组的元素从左到右分配给数组的连续字段：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.array([(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)], dtype=<span class="string">&#x27;i8, f4, f8&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="number">1</span>] = (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([(<span class="number">1</span>, <span class="number">2.</span>, <span class="number">3.</span>), (<span class="number">7</span>, <span class="number">8.</span>, <span class="number">9.</span>)],</span><br><span class="line">     dtype=[(<span class="string">&#x27;f0&#x27;</span>, <span class="string">&#x27;&lt;i8&#x27;</span>), (<span class="string">&#x27;f1&#x27;</span>, <span class="string">&#x27;&lt;f4&#x27;</span>), (<span class="string">&#x27;f2&#x27;</span>, <span class="string">&#x27;&lt;f8&#x27;</span>)])</span><br></pre></td></tr></table></figure>

<h4 id="Scalars的赋值"><a href="#Scalars的赋值" class="headerlink" title="Scalars的赋值"></a>Scalars的赋值</h4><p>分配给结构化元素的标量将分配给所有字段。将标量分配给结构化数组时，或者将非结构化数组分配给结构化数组时，会发生这种情况：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.zeros(<span class="number">2</span>, dtype=<span class="string">&#x27;i8, f4, ?, S1&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[:] = <span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([(<span class="number">3</span>, <span class="number">3.</span>, <span class="literal">True</span>, <span class="string">b&#x27;3&#x27;</span>), (<span class="number">3</span>, <span class="number">3.</span>, <span class="literal">True</span>, <span class="string">b&#x27;3&#x27;</span>)],</span><br><span class="line">      dtype=[(<span class="string">&#x27;f0&#x27;</span>, <span class="string">&#x27;&lt;i8&#x27;</span>), (<span class="string">&#x27;f1&#x27;</span>, <span class="string">&#x27;&lt;f4&#x27;</span>), (<span class="string">&#x27;f2&#x27;</span>, <span class="string">&#x27;?&#x27;</span>), (<span class="string">&#x27;f3&#x27;</span>, <span class="string">&#x27;S1&#x27;</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[:] = np.arange(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([(<span class="number">0</span>, <span class="number">0.</span>, <span class="literal">False</span>, <span class="string">b&#x27;0&#x27;</span>), (<span class="number">1</span>, <span class="number">1.</span>, <span class="literal">True</span>, <span class="string">b&#x27;1&#x27;</span>)],</span><br><span class="line">      dtype=[(<span class="string">&#x27;f0&#x27;</span>, <span class="string">&#x27;&lt;i8&#x27;</span>), (<span class="string">&#x27;f1&#x27;</span>, <span class="string">&#x27;&lt;f4&#x27;</span>), (<span class="string">&#x27;f2&#x27;</span>, <span class="string">&#x27;?&#x27;</span>), (<span class="string">&#x27;f3&#x27;</span>, <span class="string">&#x27;S1&#x27;</span>)])</span><br></pre></td></tr></table></figure>

<p>结构化数组也可以分配给非结构化数组，但前提是结构化数据类型只有一个字段：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>twofield = np.zeros(<span class="number">2</span>, dtype=[(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;i4&#x27;</span>), (<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;i4&#x27;</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>onefield = np.zeros(<span class="number">2</span>, dtype=[(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;i4&#x27;</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nostruct = np.zeros(<span class="number">2</span>, dtype=<span class="string">&#x27;i4&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>nostruct[:] = twofield</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">...</span><br><span class="line">TypeError: Cannot cast scalar <span class="keyword">from</span> dtype([(<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;&lt;i4&#x27;</span>), (<span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;&lt;i4&#x27;</span>)]) to dtype(<span class="string">&#x27;int32&#x27;</span>) according to the rule <span class="string">&#x27;unsafe&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="来自其他结构化数组的赋值"><a href="#来自其他结构化数组的赋值" class="headerlink" title="来自其他结构化数组的赋值"></a>来自其他结构化数组的赋值</h4><p>两个结构化数组之间的分配就像源元素已转换为元组然后分配给目标元素一样。也就是说，源数组的第一个字段分配给目标数组的第一个字段，第二个字段同样分配，依此类推，而不管字段名称如何。具有不同数量的字段的结构化数组不能彼此分配。未包含在任何字段中的目标结构的字节不受影响。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.zeros(<span class="number">3</span>, dtype=[(<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;i8&#x27;</span>), (<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>), (<span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;S3&#x27;</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = np.ones(<span class="number">3</span>, dtype=[(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>), (<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;S3&#x27;</span>), (<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;O&#x27;</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b[:] = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line">array([(<span class="number">0.</span>, <span class="string">b&#x27;0.0&#x27;</span>, <span class="string">b&#x27;&#x27;</span>), (<span class="number">0.</span>, <span class="string">b&#x27;0.0&#x27;</span>, <span class="string">b&#x27;&#x27;</span>), (<span class="number">0.</span>, <span class="string">b&#x27;0.0&#x27;</span>, <span class="string">b&#x27;&#x27;</span>)],</span><br><span class="line">      dtype=[(<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;&lt;f4&#x27;</span>), (<span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;S3&#x27;</span>), (<span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;O&#x27;</span>)])</span><br></pre></td></tr></table></figure>

<h4 id="涉及子数组的分配"><a href="#涉及子数组的分配" class="headerlink" title="涉及子数组的分配"></a>涉及子数组的分配</h4><p>分配给子数组的字段时，首先将指定的值广播到子数组的形状。</p>
<h3 id="索引结构化数组"><a href="#索引结构化数组" class="headerlink" title="索引结构化数组"></a>索引结构化数组</h3><h4 id="访问单个字段"><a href="#访问单个字段" class="headerlink" title="访问单个字段"></a>访问单个字段</h4><p>可以通过使用字段名称索引数组来访问和修改结构化数组的各个字段。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.array([(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">3</span>, <span class="number">4</span>)], dtype=[(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;i8&#x27;</span>), (<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;f4&#x27;</span>)])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="string">&#x27;foo&#x27;</span>]</span><br><span class="line">array([<span class="number">1</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="string">&#x27;foo&#x27;</span>] = <span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([(<span class="number">10</span>, <span class="number">2.</span>), (<span class="number">10</span>, <span class="number">4.</span>)],</span><br><span class="line">      dtype=[(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;&lt;i8&#x27;</span>), (<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;&lt;f4&#x27;</span>)])</span><br></pre></td></tr></table></figure>

<p>生成的数组是原始数组的视图。它共享相同的内存位置，写入视图将修改原始数组。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>y = x[<span class="string">&#x27;bar&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>y[:] = <span class="number">11</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([(<span class="number">10</span>, <span class="number">11.</span>), (<span class="number">10</span>, <span class="number">11.</span>)],</span><br><span class="line">      dtype=[(<span class="string">&#x27;foo&#x27;</span>, <span class="string">&#x27;&lt;i8&#x27;</span>), (<span class="string">&#x27;bar&#x27;</span>, <span class="string">&#x27;&lt;f4&#x27;</span>)])</span><br></pre></td></tr></table></figure>

<p>此视图与索引字段具有相同的dtype和itemsize，因此它通常是非结构化数组，但嵌套结构除外。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>y.dtype, y.shape, y.strides</span><br><span class="line">(dtype(<span class="string">&#x27;float32&#x27;</span>), (<span class="number">2</span>,), (<span class="number">12</span>,))</span><br></pre></td></tr></table></figure>

<p>如果访问的字段是子数组，则子数组的维度将附加到结果的形状：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.zeros((<span class="number">2</span>, <span class="number">2</span>), dtype=[(<span class="string">&#x27;a&#x27;</span>, np.int32), (<span class="string">&#x27;b&#x27;</span>, np.float64, (<span class="number">3</span>, <span class="number">3</span>))])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="string">&#x27;a&#x27;</span>].shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x[<span class="string">&#x27;b&#x27;</span>].shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>Post author:  </strong>Hai-Wei Chai (柴海伟)
  </li>
  <li class="post-copyright-link">
      <strong>Post link: </strong>
      <a href="https://hwchai.com/PythonLes04/" title="Python在科研中的应用 03：科学计算环境 NumPy">https://hwchai.com/PythonLes04/</a>
  </li>
  <li class="post-copyright-license">
      <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Python/" rel="tag"># Python</a>
              <a href="/tags/NumPy/" rel="tag"># NumPy</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/PythonLes03/" rel="prev" title="Python在科研中的应用 02：函数、流程控制语句与NumPy初步">
                  <i class="fa fa-angle-left"></i> Python在科研中的应用 02：函数、流程控制语句与NumPy初步
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/PythonLes05/" rel="next" title="Python在科研中的应用 04：NumPy 数据分析基础">
                  Python在科研中的应用 04：NumPy 数据分析基础 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2019 – 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-user"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Hai-Wei Chai (柴海伟)</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://vercel.hwchai.com/","cssUrl":"https://hwchai.com/download/Waline.css","commentCount":true,"pageview":false,"locale":{"placeholder":"请留下邮箱，若有回复您将收到提醒。QQ邮箱可以自动识别头像喔~"},"pageSize":10,"visitor":false,"comment_count":true,"meta":["nick","mail","link"],"requiredMeta":["nick"],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","emoji":["https://unpkg.com/@waline/emojis@1.0.1/bilibili"],"login":"disable","el":"#waline","comment":true,"path":"/PythonLes04/"}</script>
<link rel="stylesheet" href="https://hwchai.com/download/Waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
