<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Times+New+Roman:300,300italic,400,400italic,700,700italic%7CGeorgia:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.6.0/css/all.min.css" integrity="sha256-5eIC48iZUHmSlSUz9XtjRyK2mzQkHScZY1WdMaoz74E=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hwchai.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.21.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":true,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Python的图像分析方法是一种强大的数据处理技术，它利用多种算法和工具来提取、处理和分析图像数据。通过Python，我们可以方便地调用各种图像处理库，如OpenCV、PIL(Pillow)、SciPy等，进行图像的预处理、特征提取、图像分割、边缘检测等操作。此外，利用Python的机器学习库，如scikit-learn、TensorFlow等，我们还可以对图像进行更高级的分析，如目标检测、图像">
<meta property="og:type" content="article">
<meta property="og:title" content="Python在科研中的应用 07：Python 环境下的数字图像分析方法">
<meta property="og:url" content="https://hwchai.com/PythonLes08/index.html">
<meta property="og:site_name" content="Hai-Wei Chai&#39;s Blog">
<meta property="og:description" content="Python的图像分析方法是一种强大的数据处理技术，它利用多种算法和工具来提取、处理和分析图像数据。通过Python，我们可以方便地调用各种图像处理库，如OpenCV、PIL(Pillow)、SciPy等，进行图像的预处理、特征提取、图像分割、边缘检测等操作。此外，利用Python的机器学习库，如scikit-learn、TensorFlow等，我们还可以对图像进行更高级的分析，如目标检测、图像">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://s21.ax1x.com/2024/10/17/pAUMSfI.png">
<meta property="og:image" content="https://www.osgeo.cn/scipy/_images/interpolate-1.png">
<meta property="og:image" content="https://www.osgeo.cn/scipy/_images/interpolate-2.png">
<meta property="og:image" content="https://www.osgeo.cn/scipy/_images/interpolate-3.png">
<meta property="og:image" content="https://www.osgeo.cn/scipy/_images/interpolate-4_00_00.png">
<meta property="og:image" content="https://www.osgeo.cn/scipy/_images/interpolate-4_01_00.png">
<meta property="og:image" content="https://www.osgeo.cn/scipy/_images/interpolate-4_02_00.png">
<meta property="og:image" content="https://www.osgeo.cn/scipy/_images/interpolate-4_03_00.png">
<meta property="og:image" content="https://www.osgeo.cn/scipy/_images/interpolate-4_04_00.png">
<meta property="og:image" content="https://www.osgeo.cn/scipy/_images/interpolate-6_00_00.png">
<meta property="og:image" content="https://www.osgeo.cn/scipy/_images/interpolate-6_01_00.png">
<meta property="og:image" content="https://www.osgeo.cn/scipy/_images/spatial-1.png">
<meta property="og:image" content="https://www.osgeo.cn/scipy/_images/spatial-2.png">
<meta property="og:image" content="https://www.osgeo.cn/scipy/_images/spatial-3_00_00.png">
<meta property="og:image" content="https://www.osgeo.cn/scipy/_images/spatial-3_01_00.png">
<meta property="og:image" content="https://www.osgeo.cn/scipy/_images/spatial-4.png">
<meta property="article:published_time" content="2024-04-09T02:12:58.000Z">
<meta property="article:modified_time" content="2024-04-09T16:04:01.000Z">
<meta property="article:author" content="Hai-Wei Chai (柴海伟)">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="NumPy">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://s21.ax1x.com/2024/10/17/pAUMSfI.png">


<link rel="canonical" href="https://hwchai.com/PythonLes08/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"en","comments":true,"permalink":"https://hwchai.com/PythonLes08/","path":"PythonLes08/","title":"Python在科研中的应用 07：Python 环境下的数字图像分析方法"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Python在科研中的应用 07：Python 环境下的数字图像分析方法 | Hai-Wei Chai's Blog</title>
  







<link rel="dns-prefetch" href="https://vercel.hwchai.com/">
  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Hai-Wei Chai's Blog</p>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-house-chimney fa-fw"></i>Home</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-list fa-fw"></i>Archives</a></li><li class="menu-item menu-item-support"><a href="/support/" rel="section"><i class="fa fa-screwdriver-wrench fa-fw"></i>Support</a></li><li class="menu-item menu-item-books"><a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>Books</a></li><li class="menu-item menu-item-scholar"><a href="/scholar/" rel="section"><i class="fa fa-chart-column fa-fw"></i>Scholar</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="Searching..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Pillow-%E4%B8%8E-PIL-%E5%BA%93"><span class="nav-number">1.</span> <span class="nav-text">Pillow 与 PIL 库</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8-Image-%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text">使用 Image 类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%AF%BB%E5%86%99%E5%9B%BE%E5%83%8F"><span class="nav-number">3.</span> <span class="nav-text">读写图像</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96"><span class="nav-number">3.1.</span> <span class="nav-text">从文件读取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E6%8C%87%E5%AE%9A%E8%B7%AF%E5%BE%84%E8%AF%BB%E5%8F%96"><span class="nav-number">3.2.</span> <span class="nav-text">从指定路径读取</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E5%88%B0JPEG"><span class="nav-number">3.3.</span> <span class="nav-text">转换文件格式到JPEG</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9B%E5%BB%BA-JPEG-%E7%BC%A9%E7%95%A5%E5%9B%BE"><span class="nav-number">3.4.</span> <span class="nav-text">创建 JPEG 缩略图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%AA%8C%E8%AF%81%E5%9B%BE%E5%83%8F%E6%96%87%E4%BB%B6"><span class="nav-number">3.5.</span> <span class="nav-text">验证图像文件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%BE%E5%83%8F%E5%89%AA%E5%88%87%EF%BC%8C%E7%B2%98%E8%B4%B4%EF%BC%8C%E5%90%88%E5%B9%B6%EF%BC%8C%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2%E7%AD%89"><span class="nav-number">4.</span> <span class="nav-text">图像剪切，粘贴，合并，几何变换等</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%8E%E5%9B%BE%E5%83%8F%E4%B8%AD%E5%A4%8D%E5%88%B6%E5%87%BA%E4%B8%80%E4%B8%AA%E7%9F%A9%E5%BD%A2%E9%80%89%E5%8C%BA"><span class="nav-number">4.1.</span> <span class="nav-text">从图像中复制出一个矩形选区</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%84%E7%90%86%E5%A4%8D%E5%88%B6%E7%9A%84%E7%9F%A9%E5%BD%A2%E9%80%89%E5%8C%BA%E5%B9%B6%E7%B2%98%E8%B4%B4%E5%88%B0%E5%8E%9F%E5%9B%BE"><span class="nav-number">4.2.</span> <span class="nav-text">处理复制的矩形选区并粘贴到原图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E7%A6%BB%E5%92%8C%E5%90%88%E5%B9%B6%E9%A2%9C%E8%89%B2%E9%80%9A%E9%81%93"><span class="nav-number">4.3.</span> <span class="nav-text">分离和合并颜色通道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%A0%E4%BD%95%E5%8F%98%E6%8D%A2"><span class="nav-number">4.4.</span> <span class="nav-text">几何变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A2%9C%E8%89%B2%E5%8F%98%E6%8D%A2"><span class="nav-number">4.5.</span> <span class="nav-text">颜色变换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%8F%E5%A0%82%E7%BB%83%E4%B9%A0"><span class="nav-number">4.6.</span> <span class="nav-text">随堂练习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%A6%82%E4%BD%95%E5%B0%86PIL%E5%9B%BE%E5%83%8F%E8%BD%AC%E6%8D%A2%E4%B8%BANumPy%E6%95%B0%E7%BB%84%EF%BC%9F"><span class="nav-number">5.</span> <span class="nav-text">如何将PIL图像转换为NumPy数组？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8F%92%E5%80%BC-scipy-interpolate"><span class="nav-number">6.</span> <span class="nav-text">插值 (scipy.interpolate)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%80%E7%BB%B4%E6%8F%92%E5%80%BC-interp1d"><span class="nav-number">6.1.</span> <span class="nav-text">一维插值 (interp1d)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%9A%E5%8F%98%E9%87%8F%E6%95%B0%E6%8D%AE%E6%8F%92%E5%80%BC-griddata"><span class="nav-number">6.2.</span> <span class="nav-text">多变量数据插值 (griddata)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B7%E6%9D%A1%E6%8F%92%E5%80%BC"><span class="nav-number">6.3.</span> <span class="nav-text">样条插值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%9A%8F%E5%A0%82%E7%BB%83%E4%B9%A0-1"><span class="nav-number">6.4.</span> <span class="nav-text">随堂练习</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A9%BA%E9%97%B4%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95-scipy-spatial"><span class="nav-number">7.</span> <span class="nav-text">空间数据结构和算法 (scipy.spatial)</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Delaunay%E4%B8%89%E8%A7%92%E6%B5%8B%E9%87%8F"><span class="nav-number">7.1.</span> <span class="nav-text">Delaunay三角测量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%B8%E5%8C%85"><span class="nav-number">7.2.</span> <span class="nav-text">凸包</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Voronoi%E5%9B%BE"><span class="nav-number">7.3.</span> <span class="nav-text">Voronoi图</span></a></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Hai-Wei Chai (柴海伟)"
      src="/images/gamersky.gif">
  <p class="site-author-name" itemprop="name">Hai-Wei Chai (柴海伟)</p>
  <div class="site-description" itemprop="description">I am a slow walker, but never backwards!</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">categories</span>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/haiweichai" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;haiweichai" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chw9402@mail.ustc.edu.com" title="E-Mail → mailto:chw9402@mail.ustc.edu.com" rel="noopener me" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hwchai.com/PythonLes08/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/gamersky.gif">
      <meta itemprop="name" content="Hai-Wei Chai (柴海伟)">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hai-Wei Chai's Blog">
      <meta itemprop="description" content="I am a slow walker, but never backwards!">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Python在科研中的应用 07：Python 环境下的数字图像分析方法 | Hai-Wei Chai's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Python在科研中的应用 07：Python 环境下的数字图像分析方法
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2024-04-09 02:12:58" itemprop="dateCreated datePublished" datetime="2024-04-09T02:12:58Z">2024-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-04-09 16:04:01" itemprop="dateModified" datetime="2024-04-09T16:04:01Z">2024-04-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">In</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Programming-language/" itemprop="url" rel="index"><span itemprop="name">Programming language</span></a>
        </span>
    </span>

  
  
  <span class="post-meta-item">
    
    <span class="post-meta-item-icon">
      <i class="far fa-comment"></i>
    </span>
    <span class="post-meta-item-text">Waline: </span>
  
    <a title="waline" href="/PythonLes08/#waline" itemprop="discussionUrl">
      <span class="post-comments-count waline-comment-count" data-path="/PythonLes08/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p><img src="https://s21.ax1x.com/2024/10/17/pAUMSfI.png"></p>
<p>Python的图像分析方法是一种强大的数据处理技术，它利用多种算法和工具来提取、处理和分析图像数据。通过Python，我们可以方便地调用各种图像处理库，如OpenCV、PIL(Pillow)、SciPy等，进行图像的预处理、特征提取、图像分割、边缘检测等操作。此外，利用Python的机器学习库，如scikit-learn、TensorFlow等，我们还可以对图像进行更高级的分析，如目标检测、图像识别、图像分类等。SciPy是构建在Python的NumPy扩展上的数学算法和便利函数的集合。它通过向用户提供用于操作和可视化数据的高级命令和类，为交互式Python会话添加了强大的功能。有了SciPy，交互式Python会话将成为可与MATLAB、IDL、Octave、R-Lab和SciLab等系统相媲美的数据处理和系统原型环境。</p>
<p>Python的数字图像分析方法章节将持续3-4周的课程，包括数字图像的基础操作，图像降噪，图像分割，边缘检测，目标检测等等。本节课程我们将学习Python在数字图像分析领域的一些基础方法。</p>
<span id="more"></span>

<h2 id="Pillow-与-PIL-库"><a href="#Pillow-与-PIL-库" class="headerlink" title="Pillow 与 PIL 库"></a>Pillow 与 PIL 库</h2><p>PIL (Python Imaging Library) 是Python平台上图像处理的标准库，功能丰富，API简单易用，不过只支持到Python 2.7。</p>
<p>PIL官方网站：<a target="_blank" rel="noopener" href="http://www.pythonware.com/products/pil/">http://www.pythonware.com/products/pil/</a></p>
<p>Pillow是PIL的一个派生分支，但如今已经发展成为比PIL本身更具活力的图像处理库。</p>
<p>Pillow的Github主页：<a target="_blank" rel="noopener" href="https://github.com/python-pillow/Pillow">https://github.com/python-pillow/Pillow</a><br>Pillow的文档(对应版本v3.0.0)：<a target="_blank" rel="noopener" href="https://pillow.readthedocs.org/en/latest/handbook/index.html">https://pillow.readthedocs.org/en/latest/handbook/index.html</a></p>
<p>给Python安装Pillow非常简单，使用pip或easy_install只要一行代码即可。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在命令行使用PIP安装：</span></span><br><span class="line">pip install Pillow</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或在命令行使用easy_install安装：</span></span><br><span class="line">easy_install Pillow</span><br></pre></td></tr></table></figure>

<p>安装完成后，使用from PIL import Image就引用使用库了。如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">im = Image.<span class="built_in">open</span>(<span class="string">&quot;im.png&quot;</span>)</span><br><span class="line">im.rotate(<span class="number">45</span>).show()</span><br></pre></td></tr></table></figure>

<h2 id="使用-Image-类"><a href="#使用-Image-类" class="headerlink" title="使用 Image 类"></a>使用 Image 类</h2><p>PIL最重要的类是 <code>Image</code> class, 你可以通过多种方法创建这个类的实例；你可以从文件加载图像，或者处理其他图像, 或者从 scratch 创建。</p>
<p>要从文件加载图像，使用 <code>open()</code> 函数， 在 <code>Image</code> 模块:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">im = Image.<span class="built_in">open</span>(<span class="string">&quot;im.png&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>加载成功将返回一个 <code>Image</code> 对象。 你现在可以使用示例属性检查文件内容:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="built_in">print</span>(im.<span class="built_in">format</span>, im.size, im.mode)</span><br><span class="line"><span class="comment"># PNG (512, 512) RGB</span></span><br></pre></td></tr></table></figure>

<p><code>format</code> 这个属性标识了图像来源。如果图像不是从文件读取它的值就是None。<code>size</code>属性是一个二元tuple，包含width和height（宽度和高度，单位都是px）。 <code>mode</code> 属性定义了图像通道的数量和名称，以及像素类型和深度。常见的modes 有 “L” (luminance) 表示灰度图像, “RGB” 表示真彩色图像, 以及 “CMYK” 表示出版图像。</p>
<p>如果文件打开错误，返回 <code>IOError</code> 错误。</p>
<p>只要你有了 <code>Image</code> 类的实例，你就可以通过类的方法处理图像。比如，下列方法可以显示图像:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">im.show()</span><br></pre></td></tr></table></figure>

<p>标准的 <code>im.show()</code> 效率并不高，它需要保存图像到临时文件然后通过 xv 显示图像。你需要先安装 xv ，显示图像有助于调试和测试。</p>
<h2 id="读写图像"><a href="#读写图像" class="headerlink" title="读写图像"></a>读写图像</h2><p>PIL 模块支持大量图片格式。使用在 <code>Image</code> 模块的 <code>open()</code> 函数从磁盘读取文件。你不需要知道文件格式就能打开它，这个库能够根据文件内容自动确定文件格式。</p>
<h3 id="从文件读取"><a href="#从文件读取" class="headerlink" title="从文件读取"></a>从文件读取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fp = <span class="built_in">open</span>(<span class="string">&quot;im.png&quot;</span>, <span class="string">&quot;rb&quot;</span>)</span><br><span class="line">im = Image.<span class="built_in">open</span>(fp)</span><br></pre></td></tr></table></figure>

<h3 id="从指定路径读取"><a href="#从指定路径读取" class="headerlink" title="从指定路径读取"></a>从指定路径读取</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">im = Image.<span class="built_in">open</span>(os.path.join(os.getcwd(),<span class="string">&quot;im.png&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>要保存文件，使用 <code>Image</code> 类的 <code>save()</code> 方法。保存文件的时候文件名变得重要了。除非你指定格式，否则这个库将会以文件名的扩展名作为格式保存。</p>
<h3 id="转换文件格式到JPEG"><a href="#转换文件格式到JPEG" class="headerlink" title="转换文件格式到JPEG"></a>转换文件格式到JPEG</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> infile <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:</span><br><span class="line">    f, e = os.path.splitext(infile)</span><br><span class="line">    outfile = f + <span class="string">&quot;.jpg&quot;</span></span><br><span class="line">    <span class="keyword">if</span> infile != outfile:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            Image.<span class="built_in">open</span>(infile).convert(<span class="string">&#x27;RGB&#x27;</span>).save(outfile)</span><br><span class="line">        <span class="keyword">except</span> IOError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;cannot convert&quot;</span>, infile)</span><br></pre></td></tr></table></figure>

<p><code>argv</code>是sys模块的一个全局变量，也称sys模块的一个属性！<code>argv</code>本身为一个list类型的对象，该对象持有的第1个元素是命令行中传入的模块名、从第2个元素开始（含），均为命令行中传入的参数！</p>
<p>注意：argv持有的每个元素的类型均为str（字符串）</p>
<p><code>save()</code> 方法的第二个参数可以指定文件格式，如果你使用非标准的扩展名你必须这样做：</p>
<h3 id="创建-JPEG-缩略图"><a href="#创建-JPEG-缩略图" class="headerlink" title="创建 JPEG 缩略图"></a>创建 JPEG 缩略图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">size = (<span class="number">128</span>, <span class="number">128</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> infile <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:</span><br><span class="line">    outfile = os.path.splitext(infile)[<span class="number">0</span>] + <span class="string">&quot;.jpg&quot;</span></span><br><span class="line">    <span class="keyword">if</span> infile != outfile:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            im = Image.<span class="built_in">open</span>(infile)</span><br><span class="line">            im.thumbnail(size)</span><br><span class="line">            im.convert(<span class="string">&quot;RGB&quot;</span>).save(outfile, <span class="string">&quot;JPEG&quot;</span>)</span><br><span class="line">        <span class="keyword">except</span> IOError:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;cannot create thumbnail for&quot;</span>, infile)</span><br></pre></td></tr></table></figure>

<p>很重要的一点是这个库不会直接解码或者加载图像栅格数据。当你打开一个文件，只会读取文件头信息用来确定格式，颜色模式，大小等等，文件的剩余部分不会主动处理。这意味着打开一个图像文件的操作十分快速，跟图片大小和压缩方式无关。下面是一个简单的脚本用来快速验证大量图片。</p>
<h3 id="验证图像文件"><a href="#验证图像文件" class="headerlink" title="验证图像文件"></a>验证图像文件</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> infile <span class="keyword">in</span> sys.argv[<span class="number">1</span>:]:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">with</span> Image.<span class="built_in">open</span>(infile) <span class="keyword">as</span> im:</span><br><span class="line">            <span class="built_in">print</span>(infile, im.<span class="built_in">format</span>, <span class="string">&quot;%dx%d&quot;</span> % im.size, im.mode)</span><br><span class="line">    <span class="keyword">except</span> IOError:</span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<h2 id="图像剪切，粘贴，合并，几何变换等"><a href="#图像剪切，粘贴，合并，几何变换等" class="headerlink" title="图像剪切，粘贴，合并，几何变换等"></a>图像剪切，粘贴，合并，几何变换等</h2><p><code>Image</code> 类包含的方法允许你操作图像部分选区。使用:py:meth:~PIL.Image.Image.crop 方法获取图像的一个子矩形选区。</p>
<h3 id="从图像中复制出一个矩形选区"><a href="#从图像中复制出一个矩形选区" class="headerlink" title="从图像中复制出一个矩形选区"></a>从图像中复制出一个矩形选区</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">box = (<span class="number">100</span>, <span class="number">100</span>, <span class="number">400</span>, <span class="number">400</span>)</span><br><span class="line">region = im.crop(box)</span><br></pre></td></tr></table></figure>

<p>矩形选区有一个4元元组定义，分别表示左、上、右、下的坐标。这个库以左上角为坐标原点，单位是px，所以上诉代码复制了一个 300x300 pixels 的矩形选区。这个选区现在可以被处理并且粘贴到原图。</p>
<h3 id="处理复制的矩形选区并粘贴到原图"><a href="#处理复制的矩形选区并粘贴到原图" class="headerlink" title="处理复制的矩形选区并粘贴到原图"></a>处理复制的矩形选区并粘贴到原图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">region = region.transpose(Image.ROTATE_180)</span><br><span class="line">im.paste(region, box)</span><br></pre></td></tr></table></figure>

<p>当你粘贴矩形选区的时候必须保证尺寸一致。此外，矩形选区不能在图像外。然而你不必保证矩形选区和原图的颜色模式一致，因为矩形选区会被自动转换颜色（参看下面的 颜色变换 部分），下面是一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Rolling an image</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">roll</span>(<span class="params">image, delta</span>):</span><br><span class="line">    <span class="string">&quot;Roll an image sideways&quot;</span></span><br><span class="line"></span><br><span class="line">    xsize, ysize = image.size</span><br><span class="line"></span><br><span class="line">    delta = delta % xsize</span><br><span class="line">    <span class="keyword">if</span> delta == <span class="number">0</span>: <span class="keyword">return</span> image</span><br><span class="line"></span><br><span class="line">    part1 = image.crop((<span class="number">0</span>, <span class="number">0</span>, delta, ysize))</span><br><span class="line">    part2 = image.crop((delta, <span class="number">0</span>, xsize, ysize))</span><br><span class="line">    image.paste(part2, (<span class="number">0</span>, <span class="number">0</span>, xsize-delta, ysize))</span><br><span class="line">    image.paste(part1, (xsize-delta, <span class="number">0</span>, xsize, ysize))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> image</span><br></pre></td></tr></table></figure>

<h3 id="分离和合并颜色通道"><a href="#分离和合并颜色通道" class="headerlink" title="分离和合并颜色通道"></a>分离和合并颜色通道</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r, g, b = im.split()</span><br><span class="line">im = Image.merge(<span class="string">&quot;RGB&quot;</span>, (b, g, r))</span><br></pre></td></tr></table></figure>

<p>注意，对于单通道图像，<code>split()</code>返回图像本身。</p>
<h3 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h3><p><code>PIL.Image.Image</code>类包含了<code>resize()</code>和<code>rotate()</code>方法。前者接受一个元组，给出新的大小，后者接受以逆时针为单位的角度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">out = im.resize((<span class="number">128</span>, <span class="number">128</span>))</span><br><span class="line">out = im.rotate(<span class="number">45</span>) <span class="comment"># degrees counter-clockwise</span></span><br><span class="line">im1 = im1.rotate(<span class="number">90</span>, PIL.Image.NEAREST, expand = <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p>要以90度的步骤旋转图像，您可以使用<code>rotate()</code>方法或<code>transpose()</code>方法。后者也可用于围绕其水平或垂直轴翻转图像。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">out = im.transpose(Image.FLIP_LEFT_RIGHT)</span><br><span class="line">out = im.transpose(Image.FLIP_TOP_BOTTOM)</span><br><span class="line">out = im.transpose(Image.ROTATE_90)</span><br><span class="line">out = im.transpose(Image.ROTATE_180)</span><br><span class="line">out = im.transpose(Image.ROTATE_270)</span><br></pre></td></tr></table></figure>

<p><code>transpose()</code>方法和相应的<code>rotate()</code>方法在性能和结果上没有区别。</p>
<h3 id="颜色变换"><a href="#颜色变换" class="headerlink" title="颜色变换"></a>颜色变换</h3><p>Python成像库允许您使用<code>convert()</code>方法在不同色彩表示之间转换图像。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">im = Image.<span class="built_in">open</span>(<span class="string">&quot;im.png&quot;</span>).convert(<span class="string">&quot;L&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>该库支持每种受支持的模式与“L”和“RGB”模式之间的转换。要在其他模式之间进行转换，可能必须使用中间图像(通常是“RGB”图像)。</p>
<h3 id="随堂练习"><a href="#随堂练习" class="headerlink" title="随堂练习"></a>随堂练习</h3><blockquote class="blockquote-center">
<p>构建一张PNG格式图像，读取该图片，左右翻转后，侧向平移50个像素，沿顺时针方向旋转70度后保留完整的画幅尺寸，输出为JPEG格式。</p>

</blockquote>


<h2 id="如何将PIL图像转换为NumPy数组？"><a href="#如何将PIL图像转换为NumPy数组？" class="headerlink" title="如何将PIL图像转换为NumPy数组？"></a>如何将PIL图像转换为NumPy数组？</h2><p>从以下URL导入图像并将其转换为numpy数组。<br>URL &#x3D; ‘<a target="_blank" rel="noopener" href="https://upload.wikimedia.org/wikipedia/commons/8/8b/Denali_Mt_McKinley.jpg">https://upload.wikimedia.org/wikipedia/commons/8/8b/Denali_Mt_McKinley.jpg</a>‘</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> PIL, requests</span><br><span class="line"></span><br><span class="line"><span class="comment"># Import image from URL</span></span><br><span class="line">URL = <span class="string">&#x27;https://upload.wikimedia.org/wikipedia/commons/8/8b/Denali_Mt_McKinley.jpg&#x27;</span></span><br><span class="line">response = requests.get(URL)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Read it as Image</span></span><br><span class="line">I = Image.<span class="built_in">open</span>(BytesIO(response.content))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Optionally resize</span></span><br><span class="line">I = I.resize([<span class="number">150</span>,<span class="number">150</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Convert to numpy array</span></span><br><span class="line">arr = np.asarray(I)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Optionaly Convert it back to an image and show</span></span><br><span class="line">im = PIL.Image.fromarray(np.uint8(arr))</span><br></pre></td></tr></table></figure>




<h2 id="插值-scipy-interpolate"><a href="#插值-scipy-interpolate" class="headerlink" title="插值 (scipy.interpolate)"></a>插值 (scipy.interpolate)</h2><h3 id="一维插值-interp1d"><a href="#一维插值-interp1d" class="headerlink" title="一维插值 (interp1d)"></a>一维插值 (interp1d)</h3><p>这个 <code>interp1d</code> 中的类 <code>scipy.interpolate</code> 是一种基于固定数据点创建函数的便捷方法，可以使用线性插值在给定数据定义的域内的任何位置计算该函数。通过传递组成数据的一维向量来创建此类的实例。此类的实例定义了一个 <code>__call__</code> 方法，因此可以将其视为在已知数据值之间进行插值以获得未知值的函数(它还具有用于帮助的文档字符串)。边界处的行为可以在实例化时指定。下面的示例演示了它在线性样条插值和三次样条插值中的用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.interpolate <span class="keyword">import</span> interp1d</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, num=<span class="number">11</span>, endpoint=<span class="literal">True</span>)</span><br><span class="line">y = np.cos(-x**<span class="number">2</span>/<span class="number">9.0</span>)</span><br><span class="line">f = interp1d(x, y)</span><br><span class="line">f2 = interp1d(x, y, kind=<span class="string">&#x27;cubic&#x27;</span>)</span><br><span class="line">xnew = np.linspace(<span class="number">0</span>, <span class="number">10</span>, num=<span class="number">41</span>, endpoint=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x, y, <span class="string">&#x27;o&#x27;</span>, xnew, f(xnew), <span class="string">&#x27;-&#x27;</span>, xnew, f2(xnew), <span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">plt.legend([<span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;linear&#x27;</span>, <span class="string">&#x27;cubic&#x27;</span>], loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<img src="https://www.osgeo.cn/scipy/_images/interpolate-1.png" width="75%" alt="" align=center />



<p>插值 <code>interp1d</code> 的方法常见的可以有nearest, previous以及next，其中它们返回沿x轴最近的点、上一个点或下一个点。最近的和次要的可以被认为是因果插值过滤的特例。下面的示例使用与上一个示例中相同的数据演示它们的用法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.interpolate <span class="keyword">import</span> interp1d</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">10</span>, num=<span class="number">11</span>, endpoint=<span class="literal">True</span>)</span><br><span class="line">y = np.cos(-x**<span class="number">2</span>/<span class="number">9.0</span>)</span><br><span class="line">f1 = interp1d(x, y, kind=<span class="string">&#x27;nearest&#x27;</span>)</span><br><span class="line">f2 = interp1d(x, y, kind=<span class="string">&#x27;previous&#x27;</span>)</span><br><span class="line">f3 = interp1d(x, y, kind=<span class="string">&#x27;next&#x27;</span>)</span><br><span class="line">xnew = np.linspace(<span class="number">0</span>, <span class="number">10</span>, num=<span class="number">1001</span>, endpoint=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">plt.plot(x, y, <span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">plt.plot(xnew, f1(xnew), <span class="string">&#x27;-&#x27;</span>, xnew, f2(xnew), <span class="string">&#x27;--&#x27;</span>, xnew, f3(xnew), <span class="string">&#x27;:&#x27;</span>)</span><br><span class="line">plt.legend([<span class="string">&#x27;data&#x27;</span>, <span class="string">&#x27;nearest&#x27;</span>, <span class="string">&#x27;previous&#x27;</span>, <span class="string">&#x27;next&#x27;</span>], loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<img src="https://www.osgeo.cn/scipy/_images/interpolate-2.png" width="80%" alt="" align=center />

<h3 id="多变量数据插值-griddata"><a href="#多变量数据插值-griddata" class="headerlink" title="多变量数据插值 (griddata)"></a>多变量数据插值 (griddata)</h3><p>例如，假设您具有基础函数的多维数据 $F(x,y)$，你只知道若干个点上的值 $[(x[i],y[i])]$，它们不会形成规则的网格。</p>
<p>假设我们要对二维函数 $F(x,y)$ 进行插值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x*(<span class="number">1</span>-x)*np.cos(<span class="number">4</span>*np.pi*x) * np.sin(<span class="number">4</span>*np.pi*y**<span class="number">2</span>)**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">grid_x, grid_y = np.mgrid[<span class="number">0</span>:<span class="number">1</span>:<span class="number">100j</span>, <span class="number">0</span>:<span class="number">1</span>:<span class="number">200j</span>]</span><br></pre></td></tr></table></figure>

<p>但我们只知道它在1000个数据点的值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">points = np.random.random((<span class="number">1000</span>, <span class="number">2</span>))</span><br><span class="line">values = func(points[:,<span class="number">0</span>], points[:,<span class="number">1</span>])</span><br></pre></td></tr></table></figure>

<p>这可以通过以下方式完成 <code>griddata</code> –下面我们将尝试所有的插值方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.interpolate <span class="keyword">import</span> griddata</span><br><span class="line"></span><br><span class="line">grid_z0 = griddata(points, values, (grid_x, grid_y), method=<span class="string">&#x27;nearest&#x27;</span>)</span><br><span class="line">grid_z1 = griddata(points, values, (grid_x, grid_y), method=<span class="string">&#x27;linear&#x27;</span>)</span><br><span class="line">grid_z2 = griddata(points, values, (grid_x, grid_y), method=<span class="string">&#x27;cubic&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，所有方法都在一定程度上重现了准确的结果，但对于此光滑函数，三次样条插值提供了最好的结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.subplot(<span class="number">221</span>)</span><br><span class="line">plt.imshow(func(grid_x, grid_y).T, extent=(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>), origin=<span class="string">&#x27;lower&#x27;</span>,cmap = <span class="string">&#x27;hsv&#x27;</span>)</span><br><span class="line">plt.plot(points[:,<span class="number">0</span>], points[:,<span class="number">1</span>], <span class="string">&#x27;k.&#x27;</span>, ms=<span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Original&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">222</span>)</span><br><span class="line">plt.imshow(grid_z0.T, extent=(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>), origin=<span class="string">&#x27;lower&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Nearest&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">223</span>)</span><br><span class="line">plt.imshow(grid_z1.T, extent=(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>), origin=<span class="string">&#x27;lower&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Linear&#x27;</span>)</span><br><span class="line">plt.subplot(<span class="number">224</span>)</span><br><span class="line">plt.imshow(grid_z2.T, extent=(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>), origin=<span class="string">&#x27;lower&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Cubic&#x27;</span>)</span><br><span class="line">plt.gcf().set_size_inches(<span class="number">6</span>, <span class="number">6</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<img src="https://www.osgeo.cn/scipy/_images/interpolate-3.png" width="80%" alt="" align=center />

<h3 id="样条插值"><a href="#样条插值" class="headerlink" title="样条插值"></a>样条插值</h3><h4 id="一维中的样条插值：程序化"><a href="#一维中的样条插值：程序化" class="headerlink" title="一维中的样条插值：程序化"></a>一维中的样条插值：程序化</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> interpolate</span><br><span class="line"></span><br><span class="line"><span class="comment"># 三次样条</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">2</span>*np.pi+np.pi/<span class="number">4</span>, np.pi/<span class="number">4</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">tck = interpolate.splrep(x, y, s=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 求一条一维曲线的b-spline样条表示。给定一组数据点(x[i],y[i])，在有限区间上确定光滑样条近似。</span></span><br><span class="line"><span class="comment"># 详细信息请参照：https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.splrep.html</span></span><br><span class="line"></span><br><span class="line">xnew = np.arange(<span class="number">0</span>, <span class="number">2</span>*np.pi, np.pi/<span class="number">50</span>)</span><br><span class="line">ynew = interpolate.splev(xnew, tck, der=<span class="number">0</span>)</span><br><span class="line"><span class="comment"># 求b-spline样条曲线或它的导数。给定b样条表示的结点和系数，计算平滑多项式及其导数的值。这是对FITPACK的FORTRAN例程splev和splder的包装。</span></span><br><span class="line"><span class="comment"># der 要计算的样条导数的阶数(必须小于或等于k，即样条的阶数)。</span></span><br><span class="line"><span class="comment"># 详细信息请参照：https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.splev.html</span></span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x, y, <span class="string">&#x27;x&#x27;</span>, xnew, ynew, xnew, np.sin(xnew), x, y, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.legend([<span class="string">&#x27;Linear&#x27;</span>, <span class="string">&#x27;Cubic Spline&#x27;</span>, <span class="string">&#x27;True&#x27;</span>])</span><br><span class="line">plt.axis([-<span class="number">0.05</span>, <span class="number">6.33</span>, -<span class="number">1.05</span>, <span class="number">1.05</span>])</span><br><span class="line">plt.title(<span class="string">&#x27;Cubic-spline interpolation&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<img src="https://www.osgeo.cn/scipy/_images/interpolate-4_00_00.png" width="80%" alt="" align=center />


<h4 id="样条的导数"><a href="#样条的导数" class="headerlink" title="样条的导数"></a>样条的导数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">yder = interpolate.splev(xnew, tck, der=<span class="number">1</span>)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(xnew, yder, xnew, np.cos(xnew),<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">plt.legend([<span class="string">&#x27;Cubic Spline&#x27;</span>, <span class="string">&#x27;True&#x27;</span>])</span><br><span class="line">plt.axis([-<span class="number">0.05</span>, <span class="number">6.33</span>, -<span class="number">1.05</span>, <span class="number">1.05</span>])</span><br><span class="line">plt.title(<span class="string">&#x27;Derivative estimation from spline&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<img src="https://www.osgeo.cn/scipy/_images/interpolate-4_01_00.png" width="80%" alt="" align=center />



<h4 id="样条的所有导数"><a href="#样条的所有导数" class="headerlink" title="样条的所有导数"></a>样条的所有导数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yders = interpolate.spalde(xnew, tck)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(yders[<span class="number">0</span>])):</span><br><span class="line">   plt.plot(xnew, [d[i] <span class="keyword">for</span> d <span class="keyword">in</span> yders], <span class="string">&#x27;--&#x27;</span>, label=<span class="string">f&quot;<span class="subst">&#123;i&#125;</span> derivative&quot;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.axis([-<span class="number">0.05</span>, <span class="number">6.33</span>, -<span class="number">1.05</span>, <span class="number">1.05</span>])</span><br><span class="line">plt.title(<span class="string">&#x27;All derivatives of a B-spline&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<img src="https://www.osgeo.cn/scipy/_images/interpolate-4_02_00.png" width="80%" alt="" align=center />

<h4 id="样条的积分"><a href="#样条的积分" class="headerlink" title="样条的积分"></a>样条的积分</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">integ</span>(<span class="params">x, tck, constant=-<span class="number">1</span></span>):</span><br><span class="line">    x = np.atleast_1d(x)</span><br><span class="line">    out = np.zeros(x.shape, dtype=x.dtype)</span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(out)):</span><br><span class="line">        out[n] = interpolate.splint(<span class="number">0</span>, x[n], tck)</span><br><span class="line">    out += constant</span><br><span class="line">    <span class="keyword">return</span> out</span><br><span class="line">yint = integ(xnew, tck)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(xnew, yint, xnew, -np.cos(xnew), <span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">plt.legend([<span class="string">&#x27;Cubic Spline&#x27;</span>, <span class="string">&#x27;True&#x27;</span>])</span><br><span class="line">plt.axis([-<span class="number">0.05</span>, <span class="number">6.33</span>, -<span class="number">1.05</span>, <span class="number">1.05</span>])</span><br><span class="line">plt.title(<span class="string">&#x27;Integral estimation from spline&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<img src="https://www.osgeo.cn/scipy/_images/interpolate-4_03_00.png" width="80%" alt="" align=center />

<p>样条的根</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interpolate.sproot(tck)</span><br><span class="line">array([<span class="number">3.1416</span>])</span><br></pre></td></tr></table></figure>

<p>请注意， <code>sproot</code> 在近似区间的边缘找不到明显的解。如果我们在稍微大一点的间隔上定义样条，我们可以恢复两个根：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(-np.pi/<span class="number">4</span>, <span class="number">2.</span>*np.pi + np.pi/<span class="number">4</span>, <span class="number">21</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">tck = interpolate.splrep(x, y, s=<span class="number">0</span>)</span><br><span class="line">interpolate.sproot(tck)</span><br><span class="line">array([<span class="number">0.</span>, <span class="number">3.1416</span>])</span><br></pre></td></tr></table></figure>

<p>参数样条</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">t = np.arange(<span class="number">0</span>, <span class="number">1.1</span>, <span class="number">.1</span>)</span><br><span class="line">x = np.sin(<span class="number">2</span>*np.pi*t)</span><br><span class="line">y = np.cos(<span class="number">2</span>*np.pi*t)</span><br><span class="line">tck, u = interpolate.splprep([x, y], s=<span class="number">0</span>)</span><br><span class="line">unew = np.arange(<span class="number">0</span>, <span class="number">1.01</span>, <span class="number">0.01</span>)</span><br><span class="line">out = interpolate.splev(unew, tck)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x, y, <span class="string">&#x27;x&#x27;</span>, out[<span class="number">0</span>], out[<span class="number">1</span>], np.sin(<span class="number">2</span>*np.pi*unew), np.cos(<span class="number">2</span>*np.pi*unew), x, y, <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line">plt.legend([<span class="string">&#x27;Linear&#x27;</span>, <span class="string">&#x27;Cubic Spline&#x27;</span>, <span class="string">&#x27;True&#x27;</span>])</span><br><span class="line">plt.axis([-<span class="number">1.05</span>, <span class="number">1.05</span>, -<span class="number">1.05</span>, <span class="number">1.05</span>])</span><br><span class="line">plt.title(<span class="string">&#x27;Spline of parametrically-defined curve&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<img src="https://www.osgeo.cn/scipy/_images/interpolate-4_04_00.png" width="80%" alt="" align=center />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> interpolate</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在稀疏的20x20网格上定义函数</span></span><br><span class="line">x_edges, y_edges = np.mgrid[-<span class="number">1</span>:<span class="number">1</span>:<span class="number">21j</span>, -<span class="number">1</span>:<span class="number">1</span>:<span class="number">21j</span>]</span><br><span class="line">x = x_edges[:-<span class="number">1</span>, :-<span class="number">1</span>] + np.diff(x_edges[:<span class="number">2</span>, <span class="number">0</span>])[<span class="number">0</span>] / <span class="number">2.</span></span><br><span class="line">y = y_edges[:-<span class="number">1</span>, :-<span class="number">1</span>] + np.diff(y_edges[<span class="number">0</span>, :<span class="number">2</span>])[<span class="number">0</span>] / <span class="number">2.</span></span><br><span class="line">z = (x+y) * np.exp(-<span class="number">6.0</span>*(x*x+y*y))</span><br><span class="line">plt.figure()</span><br><span class="line">lims = <span class="built_in">dict</span>(cmap=<span class="string">&#x27;RdBu_r&#x27;</span>, vmin=-<span class="number">0.25</span>, vmax=<span class="number">0.25</span>)</span><br><span class="line">plt.pcolormesh(x_edges, y_edges, z, shading=<span class="string">&#x27;flat&#x27;</span>, **lims)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.title(<span class="string">&quot;Sparsely sampled function.&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<img src="https://www.osgeo.cn/scipy/_images/interpolate-6_00_00.png" width="80%" alt="" align=center />


<p>新的70x70网格上的插值函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">xnew_edges, ynew_edges = np.mgrid[-<span class="number">1</span>:<span class="number">1</span>:<span class="number">71j</span>, -<span class="number">1</span>:<span class="number">1</span>:<span class="number">71j</span>]</span><br><span class="line">xnew = xnew_edges[:-<span class="number">1</span>, :-<span class="number">1</span>] + np.diff(xnew_edges[:<span class="number">2</span>, <span class="number">0</span>])[<span class="number">0</span>] / <span class="number">2.</span></span><br><span class="line">ynew = ynew_edges[:-<span class="number">1</span>, :-<span class="number">1</span>] + np.diff(ynew_edges[<span class="number">0</span>, :<span class="number">2</span>])[<span class="number">0</span>] / <span class="number">2.</span></span><br><span class="line">tck = interpolate.bisplrep(x, y, z, s=<span class="number">0</span>)</span><br><span class="line">znew = interpolate.bisplev(xnew[:,<span class="number">0</span>], ynew[<span class="number">0</span>,:], tck)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.pcolormesh(xnew_edges, ynew_edges, znew, shading=<span class="string">&#x27;flat&#x27;</span>, **lims)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.title(<span class="string">&quot;Interpolated function.&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<img src="https://www.osgeo.cn/scipy/_images/interpolate-6_01_00.png" width="80%" alt="" align=center />


<h3 id="随堂练习-1"><a href="#随堂练习-1" class="headerlink" title="随堂练习"></a>随堂练习</h3><blockquote class="blockquote-center">
<p>定义一个三次二元函数，在[-10,10] x [-10,10]定义域范围内随机生成1000个点，并计算函数值。通过插值方法获取每[0.01 x 0.01]间隔的网格点处的函数值。</p>

</blockquote>


<h2 id="空间数据结构和算法-scipy-spatial"><a href="#空间数据结构和算法-scipy-spatial" class="headerlink" title="空间数据结构和算法 (scipy.spatial)"></a>空间数据结构和算法 (scipy.spatial)</h2><p>SciPy通过利用Qhull类库，spatial可以计算三角剖分、Voronoi图和凸包等等。此外，它还包含 KDTree 最近邻点查询的实现，以及各种度量中距离计算的实用程序。</p>
<h3 id="Delaunay三角测量"><a href="#Delaunay三角测量" class="headerlink" title="Delaunay三角测量"></a>Delaunay三角测量</h3><p>Delaunay三角剖分是将一组点细分为一组不重叠的三角形，这样任何三角形的外接圆内都没有点。在实践中，这样的三角剖分往往会避免带有小角度的三角形。</p>
<p>可以使用以下方法计算Delaunay三角剖分 scipy.spatial 具体如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.spatial <span class="keyword">import</span> Delaunay</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">points = np.array([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1.1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line">tri = Delaunay(points)</span><br></pre></td></tr></table></figure>

<p>我们可以把它形象化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.triplot(points[:,<span class="number">0</span>], points[:,<span class="number">1</span>], tri.simplices)</span><br><span class="line">plt.plot(points[:,<span class="number">0</span>], points[:,<span class="number">1</span>], <span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> j, p <span class="keyword">in</span> <span class="built_in">enumerate</span>(points):</span><br><span class="line">    plt.text(p[<span class="number">0</span>]-<span class="number">0.03</span>, p[<span class="number">1</span>]+<span class="number">0.03</span>, j, ha=<span class="string">&#x27;right&#x27;</span>) <span class="comment"># label the points</span></span><br><span class="line"><span class="keyword">for</span> j, s <span class="keyword">in</span> <span class="built_in">enumerate</span>(tri.simplices):</span><br><span class="line">    p = points[s].mean(axis=<span class="number">0</span>)</span><br><span class="line">    plt.text(p[<span class="number">0</span>], p[<span class="number">1</span>], <span class="string">&#x27;#%d&#x27;</span> % j, ha=<span class="string">&#x27;center&#x27;</span>) <span class="comment"># label triangles</span></span><br><span class="line">plt.xlim(-<span class="number">0.5</span>, <span class="number">1.5</span>); plt.ylim(-<span class="number">0.5</span>, <span class="number">1.5</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<img src="https://www.osgeo.cn/scipy/_images/spatial-1.png" width="60%" alt="" align=center />


<p>三角剖分的结构按以下方式编码： simplices 属性包含 points 组成三角形的数组。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">1</span></span><br><span class="line">tri.simplices[i,:]</span><br><span class="line"><span class="comment"># array([3, 1, 0], dtype=int32)</span></span><br><span class="line"></span><br><span class="line">points[tri.simplices[i,:]]</span><br><span class="line"><span class="comment"># array([[ 1. ,  1. ],</span></span><br><span class="line"><span class="comment">#        [ 0. ,  1.1],</span></span><br><span class="line"><span class="comment">#        [ 0. ,  0. ]])</span></span><br></pre></td></tr></table></figure>

<p>此外，还可以找到相邻三角形：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tri.neighbors[i]</span><br><span class="line"># array([-1,  0, -1], dtype=int32)</span><br></pre></td></tr></table></figure>

<p>这告诉我们这个三角形有#0号三角形作为邻居，但没有其他邻居。此外，它还告诉我们邻居0与三角形的顶点1相对：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">points[tri.simplices[i, <span class="number">1</span>]]</span><br><span class="line"><span class="comment"># array([ 0. ,  1.1])</span></span><br></pre></td></tr></table></figure>

<p>事实上，从数字上，我们可以看到情况是这样的。</p>
<p>Qhull还可以对高维点集执行细分以简化(例如，在3-D中细分为四面体)。</p>
<p>共面点</p>
<p>重要的是要注意到，不是 all 由于形成三角剖分的数值精度问题，点必然显示为三角剖分的顶点。请考虑具有重复点的上述内容：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">points = np.array([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line">tri = Delaunay(points)</span><br><span class="line">np.unique(tri.simplices.ravel())</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], dtype=int32)</span><br></pre></td></tr></table></figure>

<p>请注意，重复的点#4不会作为三角剖分的顶点出现。这件事已被记录在案：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tri.coplanar</span><br><span class="line">array([[<span class="number">4</span>, <span class="number">0</span>, <span class="number">3</span>]], dtype=int32)</span><br></pre></td></tr></table></figure>

<p>这意味着点4位于三角形0和顶点3附近，但不包括在三角剖分中。</p>
<p>请注意，这种退化不仅可能是因为重复的点，也可能是由于更复杂的几何原因，即使在乍看起来表现良好的点集中也是如此。</p>
<p>但是，Qhull具有“qj”选项，该选项指示它随机扰乱输入数据，直到解决退化问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">tri = Delaunay(points, qhull_options=<span class="string">&quot;QJ Pp&quot;</span>)</span><br><span class="line">points[tri.simplices]</span><br><span class="line">array([[[<span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>]],</span><br><span class="line">       [[<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">0</span>]],</span><br><span class="line">       [[<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">0</span>, <span class="number">0</span>]],</span><br><span class="line">       [[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">1</span>, <span class="number">1</span>]]])</span><br></pre></td></tr></table></figure>

<p>出现了两个新的三角形。然而，我们看到它们是退化的，面积为零。</p>
<h3 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h3><p>凸包是包含给定点集中所有点的最小凸对象。</p>
<p>这些值可以通过中的qhull包装器进行计算。 scipy.spatial 具体如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.spatial <span class="keyword">import</span> ConvexHull</span><br><span class="line">rng = np.random.default_rng()</span><br><span class="line">points = rng.random((<span class="number">30</span>, <span class="number">2</span>))   <span class="comment"># 30 random points in 2-D</span></span><br><span class="line">hull = ConvexHull(points)</span><br></pre></td></tr></table></figure>

<p>凸包被表示为一组N个1-D简化，在2-D中表示线段。存储方案与上面讨论的Delaunay三角剖分中的简化完全相同。</p>
<p>我们可以举例说明上述结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">plt.plot(points[:,<span class="number">0</span>], points[:,<span class="number">1</span>], <span class="string">&#x27;o&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> simplex <span class="keyword">in</span> hull.simplices:</span><br><span class="line">    plt.plot(points[simplex,<span class="number">0</span>], points[simplex,<span class="number">1</span>], <span class="string">&#x27;k-&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<img src="https://www.osgeo.cn/scipy/_images/spatial-2.png" width="60%" alt="" align=center />

<p>同样的情况也可以通过以下方式实现 <code>scipy.spatial.convex_hull_plot_2d</code>。</p>
<h3 id="Voronoi图"><a href="#Voronoi图" class="headerlink" title="Voronoi图"></a>Voronoi图</h3><p>Voronoi图是将空间细分为一组给定点的最近邻域。</p>
<p>使用以下两种方法可以接近此对象scipy.spatial 。首先，可以使用 KDTree 要回答“哪个点最接近这个点”的问题，并这样定义区域：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.spatial <span class="keyword">import</span> KDTree</span><br><span class="line">points = np.array([[<span class="number">0</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">0</span>], [<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">                   [<span class="number">2</span>, <span class="number">0</span>], [<span class="number">2</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">2</span>]])</span><br><span class="line">tree = KDTree(points)</span><br><span class="line">tree.query([<span class="number">0.1</span>, <span class="number">0.1</span>])</span><br><span class="line">(<span class="number">0.14142135623730953</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>所以重点是 (0.1, 0.1) 属于区域 0 。在颜色方面：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(-<span class="number">0.5</span>, <span class="number">2.5</span>, <span class="number">31</span>)</span><br><span class="line">y = np.linspace(-<span class="number">0.5</span>, <span class="number">2.5</span>, <span class="number">33</span>)</span><br><span class="line">xx, yy = np.meshgrid(x, y)</span><br><span class="line">xy = np.c_[xx.ravel(), yy.ravel()]</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">dx_half, dy_half = np.diff(x[:<span class="number">2</span>])[<span class="number">0</span>] / <span class="number">2.</span>, np.diff(y[:<span class="number">2</span>])[<span class="number">0</span>] / <span class="number">2.</span></span><br><span class="line">x_edges = np.concatenate((x - dx_half, [x[-<span class="number">1</span>] + dx_half]))</span><br><span class="line">y_edges = np.concatenate((y - dy_half, [y[-<span class="number">1</span>] + dy_half]))</span><br><span class="line">plt.pcolormesh(x_edges, y_edges, tree.query(xy)[<span class="number">1</span>].reshape(<span class="number">33</span>, <span class="number">31</span>), shading=<span class="string">&#x27;flat&#x27;</span>)</span><br><span class="line">plt.plot(points[:,<span class="number">0</span>], points[:,<span class="number">1</span>], <span class="string">&#x27;ko&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<img src="https://www.osgeo.cn/scipy/_images/spatial-3_00_00.png" width="60%" alt="" align=center />

<p>然而，这并没有给出作为几何对象的Voronoi图。</p>
<p>线和点的表示可以通过中的qhull包装器再次获得 scipy.spatial：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy.spatial <span class="keyword">import</span> Voronoi</span><br><span class="line">vor = Voronoi(points)</span><br><span class="line">vor.vertices</span><br><span class="line">array([[<span class="number">0.5</span>, <span class="number">0.5</span>],</span><br><span class="line">       [<span class="number">0.5</span>, <span class="number">1.5</span>],</span><br><span class="line">       [<span class="number">1.5</span>, <span class="number">0.5</span>],</span><br><span class="line">       [<span class="number">1.5</span>, <span class="number">1.5</span>]])</span><br></pre></td></tr></table></figure>

<p>Voronoi顶点表示形成Voronoi区域的多边形边的点集。在本例中，有9个不同的区域：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vor.regions</span><br><span class="line">[[], [-<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>], [<span class="number">3</span>, -<span class="number">1</span>, <span class="number">2</span>], [-<span class="number">1</span>, <span class="number">3</span>], [-<span class="number">1</span>, <span class="number">2</span>], [<span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>], [<span class="number">2</span>, -<span class="number">1</span>, <span class="number">0</span>], [<span class="number">3</span>, -<span class="number">1</span>, <span class="number">1</span>]]</span><br></pre></td></tr></table></figure>

<p>负值 -1 再次表示无穷远处的一个点。事实上，只有一个地区， [0, 1, 3, 2]，是有界的。请注意，由于与上面的Delaunay三角剖分中类似的数值精度问题，Voronoi区域可能比输入点少。</p>
<p>将分隔区域的脊（二维中的线）描述为与凸面壳片类似的简化集合：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vor.ridge_vertices</span><br><span class="line">[[-<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">0</span>], [-<span class="number">1</span>, <span class="number">1</span>], [-<span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>], [-<span class="number">1</span>, <span class="number">3</span>], [-<span class="number">1</span>, <span class="number">2</span>], [<span class="number">2</span>, <span class="number">3</span>], [-<span class="number">1</span>, <span class="number">3</span>], [-<span class="number">1</span>, <span class="number">2</span>], [<span class="number">1</span>, <span class="number">3</span>], [<span class="number">0</span>, <span class="number">2</span>]]</span><br></pre></td></tr></table></figure>

<p>这些数字表示组成线段的Voronoi顶点的索引。 -1 又是一个无穷远的点-12条直线中只有4条是有界线段，而其他的延伸到无穷远。</p>
<p>Voronoi山脊垂直于输入点之间绘制的线。还记录了每个脊对应的两个点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vor.ridge_points</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">       [<span class="number">7</span>, <span class="number">6</span>],</span><br><span class="line">       [<span class="number">7</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">8</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">6</span>, <span class="number">3</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">       [<span class="number">4</span>, <span class="number">3</span>]], dtype=int32)</span><br></pre></td></tr></table></figure>

<p>这些信息加在一起，足以构成完整的图表。</p>
<p>我们可以把它画成如下图。首先，点和Voronoi顶点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plt.plot(points[:, <span class="number">0</span>], points[:, <span class="number">1</span>], <span class="string">&#x27;o&#x27;</span>)</span><br><span class="line">plt.plot(vor.vertices[:, <span class="number">0</span>], vor.vertices[:, <span class="number">1</span>], <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">plt.xlim(-<span class="number">1</span>, <span class="number">3</span>); plt.ylim(-<span class="number">1</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>绘制有限线段与绘制凸壳一样，但现在我们必须注意无限边：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> simplex <span class="keyword">in</span> vor.ridge_vertices:</span><br><span class="line">    simplex = np.asarray(simplex)</span><br><span class="line">    <span class="keyword">if</span> np.<span class="built_in">all</span>(simplex &gt;= <span class="number">0</span>):</span><br><span class="line">        plt.plot(vor.vertices[simplex, <span class="number">0</span>], vor.vertices[simplex, <span class="number">1</span>], <span class="string">&#x27;k-&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>延伸到无穷远的山脊需要稍微小心一点：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">center = points.mean(axis=<span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> pointidx, simplex <span class="keyword">in</span> <span class="built_in">zip</span>(vor.ridge_points, vor.ridge_vertices):</span><br><span class="line">    simplex = np.asarray(simplex)</span><br><span class="line">    <span class="keyword">if</span> np.<span class="built_in">any</span>(simplex &lt; <span class="number">0</span>):</span><br><span class="line">        i = simplex[simplex &gt;= <span class="number">0</span>][<span class="number">0</span>] <span class="comment"># finite end Voronoi vertex</span></span><br><span class="line">        t = points[pointidx[<span class="number">1</span>]] - points[pointidx[<span class="number">0</span>]]  <span class="comment"># tangent</span></span><br><span class="line">        t = t / np.linalg.norm(t)</span><br><span class="line">        n = np.array([-t[<span class="number">1</span>], t[<span class="number">0</span>]]) <span class="comment"># normal</span></span><br><span class="line">        midpoint = points[pointidx].mean(axis=<span class="number">0</span>)</span><br><span class="line">        far_point = vor.vertices[i] + np.sign(np.dot(midpoint - center, n)) * n * <span class="number">100</span></span><br><span class="line">        plt.plot([vor.vertices[i,<span class="number">0</span>], far_point[<span class="number">0</span>]],</span><br><span class="line">                 [vor.vertices[i,<span class="number">1</span>], far_point[<span class="number">1</span>]], <span class="string">&#x27;k--&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<img src="https://www.osgeo.cn/scipy/_images/spatial-3_01_00.png" width="60%" alt="" align=center />

<p>也可以使用以下命令创建此图 <code>scipy.spatial.voronoi_plot_2d</code> 。</p>
<p>Vornoi图可以用来创作有趣的创作艺术。尝试使用此设置 mandala 函数来创建您自己的！</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> spatial</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">mandala</span>(<span class="params">n_iter, n_points, radius</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Creates a mandala figure using Voronoi tesselations.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    n_iter : int</span></span><br><span class="line"><span class="string">        Number of iterations, i.e. how many times the equidistant points will</span></span><br><span class="line"><span class="string">        be generated.</span></span><br><span class="line"><span class="string">    n_points : int</span></span><br><span class="line"><span class="string">        Number of points to draw per iteration.</span></span><br><span class="line"><span class="string">    radius : scalar</span></span><br><span class="line"><span class="string">        The radial expansion factor.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    fig : matplotlib.Figure instance</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Notes</span></span><br><span class="line"><span class="string">    -----</span></span><br><span class="line"><span class="string">    This code is adapted from the work of Audrey Roy Greenfeld [1]_ and Carlos</span></span><br><span class="line"><span class="string">    Focil-Espinosa [2]_, who created beautiful mandalas with Python code.  That</span></span><br><span class="line"><span class="string">    code in turn was based on Antonio Sánchez Chinchón&#x27;s R code [3]_.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    References</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    .. [1] https://www.codemakesmehappy.com/2019/09/voronoi-mandalas.html</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. [2] https://github.com/CarlosFocil/mandalapy</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    .. [3] https://github.com/aschinchon/mandalas</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">10</span>, <span class="number">10</span>))</span><br><span class="line">    ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">    ax.set_axis_off()</span><br><span class="line">    ax.set_aspect(<span class="string">&#x27;equal&#x27;</span>, adjustable=<span class="string">&#x27;box&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    angles = np.linspace(<span class="number">0</span>, <span class="number">2</span>*np.pi * (<span class="number">1</span> - <span class="number">1</span>/n_points), num=n_points) + np.pi/<span class="number">2</span></span><br><span class="line">    <span class="comment"># Starting from a single center point, add points iteratively</span></span><br><span class="line">    xy = np.array([[<span class="number">0</span>, <span class="number">0</span>]])</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(n_iter):</span><br><span class="line">        t1 = np.array([])</span><br><span class="line">        t2 = np.array([])</span><br><span class="line">        <span class="comment"># Add `n_points` new points around each existing point in this iteration</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(xy.shape[<span class="number">0</span>]):</span><br><span class="line">            t1 = np.append(t1, xy[i, <span class="number">0</span>] + radius**k * np.cos(angles))</span><br><span class="line">            t2 = np.append(t2, xy[i, <span class="number">1</span>] + radius**k * np.sin(angles))</span><br><span class="line"></span><br><span class="line">        xy = np.column_stack((t1, t2))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Create the Mandala figure via a Voronoi plot</span></span><br><span class="line">    spatial.voronoi_plot_2d(spatial.Voronoi(xy), ax=ax)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fig</span><br><span class="line"><span class="comment"># Modify the following parameters in order to get different figures</span></span><br><span class="line">n_iter = <span class="number">3</span></span><br><span class="line">n_points = <span class="number">6</span></span><br><span class="line">radius = <span class="number">4</span></span><br><span class="line">fig = mandala(n_iter, n_points, radius)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<img src="https://www.osgeo.cn/scipy/_images/spatial-4.png" width="60%" alt="" align=center />
    </div>

    
    
    

    <footer class="post-footer">
          

<div class="post-copyright">
<ul>
  <li class="post-copyright-author">
      <strong>Post author:  </strong>Hai-Wei Chai (柴海伟)
  </li>
  <li class="post-copyright-link">
      <strong>Post link: </strong>
      <a href="https://hwchai.com/PythonLes08/" title="Python在科研中的应用 07：Python 环境下的数字图像分析方法">https://hwchai.com/PythonLes08/</a>
  </li>
  <li class="post-copyright-license">
      <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> unless stating additionally.
  </li>
</ul>
</div>

          <div class="post-tags">
              <a href="/tags/Python/" rel="tag"># Python</a>
              <a href="/tags/NumPy/" rel="tag"># NumPy</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/PythonLes07/" rel="prev" title="Python在科研中的应用 06：NumPy 数据分析进阶">
                  <i class="fa fa-angle-left"></i> Python在科研中的应用 06：NumPy 数据分析进阶
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/PythonLes09/" rel="next" title="Python 在科研中的应用 08：Python 环境下的数字图像降噪">
                  Python 在科研中的应用 08：Python 环境下的数字图像降噪 <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments" id="waline"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 2019 – 
    <span itemprop="copyrightYear">2026</span>
    <span class="with-love">
      <i class="fa fa-user"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Hai-Wei Chai (柴海伟)</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/4.0.7/pangu.min.js" integrity="sha256-j+yj56cdEY2CwkVtGyz18fNybFGpMGJ8JxG3GSyO2+I=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>




  <script src="/js/third-party/fancybox.js"></script>



  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"all","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/js/third-party/math/mathjax.js"></script>


<script class="next-config" data-name="waline" type="application/json">{"lang":"zh-cn","enable":true,"serverURL":"https://vercel.hwchai.com/","cssUrl":"https://hwchai.com/download/Waline.css","commentCount":true,"pageview":false,"locale":{"placeholder":"请留下邮箱，若有回复您将收到提醒。QQ邮箱可以自动识别头像喔~"},"pageSize":10,"visitor":false,"comment_count":true,"meta":["nick","mail","link"],"requiredMeta":["nick"],"libUrl":"//unpkg.com/@waline/client@v2/dist/waline.js","emoji":["https://unpkg.com/@waline/emojis@1.0.1/bilibili"],"login":"disable","el":"#waline","comment":true,"path":"/PythonLes08/"}</script>
<link rel="stylesheet" href="https://hwchai.com/download/Waline.css">
<script>
document.addEventListener('page:loaded', () => {
  NexT.utils.loadComments(CONFIG.waline.el).then(() =>
    NexT.utils.getScript(CONFIG.waline.libUrl, { condition: window.Waline })
  ).then(() => 
    Waline.init(Object.assign({}, CONFIG.waline,{ el: document.querySelector(CONFIG.waline.el) }))
  );
});
</script>

</body>
</html>
